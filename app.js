// 应用状态管理
// 添加字符串哈希方法
String.prototype.hashCode = function () {
    let hash = 0;
    if (this.length === 0) return hash;
    for (let i = 0; i < this.length; i++) {
        const char = this.charCodeAt(i);
        hash = (hash << 5) - hash + char;
        hash = hash & hash; // 转换为32位整数
    }
    return hash;
};

const appState = {
    currentStep: 'selection', // selection, story, battle, achievement, tutorial
    selectedCharacter: null,
    currentStoryIndex: 0,
    currentLevel: 1,
    currentQuestionIndex: 0,
    selectedOptions: [],
    score: 0,
    levelAttempts: {}, // 记录每个关卡的尝试次数
    retryQuestions: [], // 存储需要重练的错题
    wrongAnswersCount: {}, // 记录每个关卡的错题数量
    wrongQuestionIds: {}, // 记录每个关卡答错的不同题目ID集合
    typewriterTimerId: null, // 保存打字机效果的定时器ID
    shareProgress: {
        // 记录分享解锁进度
        totalShared: 0, // 总共成功分享的次数
        unlockedFeatures: [], // 已解锁的功能列表
    },
    analytics: {
        totalPlays: 0,
        characterSelection: {
            cyber: 0,
            heritage: 0,
            space: 0,
            math: 0,
        },
        storyConversion: 0,
        battleCompletion: 0,
        levelCompletions: {}, // 记录每个关卡的完成情况
    },
};

// 角色数据
const characters = {
    // Cyber侦探角色
    cyber: {
        name: 'Cyber侦探',
        tagline: '用逻辑解决数字世界的谜题',
        description: '在数字化的未来世界中，你将扮演一名擅长逻辑推理的Cyber侦探，解决各种复杂的数字谜题和安全挑战。',
        story: [
            {
                text: '你是一名备受尊敬的Cyber侦探，专门解决数字世界中的复杂谜题。今天，你接到了一个神秘的委托，需要破解一个加密的信息，这个信息可能揭示一个重大的网络安全威胁。',
                next: true,
            },
            {
                text: '通过初步调查，你发现这个加密信息使用了多层逻辑加密，需要解决一系列逻辑谜题才能逐层破解。每解开一个谜题，你就能获得更多关于这个网络威胁的线索。',
                next: true,
            },
            {
                text: '现在，你准备好迎接第一个逻辑挑战了吗？这将是你成为传奇Cyber侦探的第一步！',
                next: true,
                startBattle: true,
            },
        ],
        levels: [
            {
                title: '数字初入者',
                description: '作为一名新手侦探，你需要掌握基本的数字规律识别能力，这是成为数字世界守护者的第一步。',
                lifeGoal: '',
                questions: [
                    {
                        content: '在数字世界中，有一个数列：2, 5, 11, 23, 47, ? 下一个数字是什么？',
                        options: ['94', '95', '100', '89'],
                        correctIndex: 1,
                        explanation:
                            '这个数列的规律是：每个数都是前一个数的2倍加1，即2*2+1=5, 5*2+1=11, 11*2+1=23, 23*2+1=47, 所以下一个数是47*2+1=95。',
                        lifeLesson: '在解决数字谜题时，观察模式是关键，这也是成为优秀侦探的基础能力。',
                    },
                    {
                        content:
                            '在数字加密中，有一种简单的替换密码，将字母A-Z分别替换为数字1-26。那么单词"CYBER"对应的数字序列是什么？',
                        options: ['3 25 2 5 18', '3 25 2 5 19', '3 25 2 13 18', '3 25 2 14 18'],
                        correctIndex: 0,
                        explanation: 'C对应3，Y对应25，B对应2，E对应5，R对应18，所以CYBER对应的数字序列是3 25 2 5 18。',
                        lifeLesson: '密码学是网络安全的基础，掌握简单的密码规则有助于你成为出色的数字侦探。',
                    },
                    {
                        content: '在二进制系统中，十进制数13对应的二进制表示是什么？',
                        options: ['1001', '1101', '1011', '1110'],
                        correctIndex: 1,
                        explanation: '13 = 8 + 4 + 1 = 2^3 + 2^2 + 2^0，所以二进制表示为1101。',
                        lifeLesson: '二进制是计算机的基础语言，了解二进制与十进制的转换是进入数字世界的第一步。',
                    },
                    {
                        content: '观察以下数字序列：1, 4, 9, 16, 25, ? 下一个数字是什么？',
                        options: ['30', '35', '36', '49'],
                        correctIndex: 2,
                        explanation: '这是一个平方数序列，1=1², 4=2², 9=3², 16=4², 25=5²，所以下一个数是6²=36。',
                        lifeLesson: '识别数学模式是解决数字谜题的核心能力，这在网络安全分析中也非常重要。',
                    },
                    {
                        content: '数字3, 6, 12, 24, 48, ? 的下一个数是多少？',
                        options: ['60', '72', '84', '96'],
                        correctIndex: 3,
                        explanation: '这个数列的规律是每个数都是前一个数的2倍，所以下一个数是48×2=96。',
                        lifeLesson: '指数增长是数字世界中的常见模式，理解它有助于分析数据增长趋势。',
                    },
                ],
                successMessage:
                    '恭喜你完成了数字初入者关卡！你已经掌握了基础的数字规律识别能力，这将帮助你在未来的侦探生涯中解决更复杂的谜题。',
            },
            {
                title: '逻辑推理师',
                description: '现在你需要运用逻辑推理能力来解决更加复杂的问题。',
                lifeGoal: '优秀的侦探需要具备严密的逻辑思维，这将帮助你在复杂的线索中找到真相。',
                questions: [
                    {
                        content:
                            '在一个虚拟迷宫中，你遇到了三扇门，只有一扇门能通往安全区域。三扇门上分别写着：\n门1：这扇门不是正确的\n门2：这扇门是正确的\n门3：门2不是正确的\n已知只有一扇门上的话是真的，请问哪扇门是正确的？',
                        options: ['门1', '门2', '门3', '没有正确的门'],
                        correctIndex: 0,
                        explanation:
                            '如果门1是正确的，那么门1的话是假的，门2的话是假的，门3的话是真的，符合条件。如果门2是正确的，那么门1和门2的话都是真的，不符合。如果门3是正确的，那么门1和门3的话都是真的，也不符合。所以正确的门是门1。',
                        lifeLesson: '在面对矛盾的信息时，逻辑推理是辨别真伪的有力工具。',
                    },
                    {
                        content:
                            '在逻辑电路中，有一个简单的布尔表达式：(A ∧ B) ∨ (¬A ∧ ¬B)。这个表达式的逻辑功能是什么？',
                        options: ['与门', '或门', '异或门', '同或门'],
                        correctIndex: 3,
                        explanation: '这个表达式表示当A和B同时为真或同时为假时，结果为真，这正是同或门的逻辑功能。',
                        lifeLesson: '理解逻辑运算有助于你分析复杂的逻辑关系，是解决高级谜题的基础。',
                    },
                    {
                        content:
                            '在一个逻辑谜题中，有三个嫌疑人甲、乙、丙。已知：\n1. 只有一个人是罪犯\n2. 每个人都说了两句话\n甲说："我不是罪犯，乙是罪犯。"\n乙说："我不是罪犯，丙是罪犯。"\n丙说："我不是罪犯，甲在说谎。"\n如果每个人都只说了一句真话和一句假话，那么谁是罪犯？',
                        options: ['甲', '乙', '丙', '无法确定'],
                        correctIndex: 0,
                        explanation:
                            '假设甲是罪犯，那么甲的第一句话是假的，第二句话也是假的，不符合条件。假设乙是罪犯，那么甲的第一句话是真的，第二句话也是真的，不符合。假设丙是罪犯，那么乙的第一句话是真的，第二句话也是真的，不符合。通过仔细分析，实际上甲是罪犯，因为当甲是罪犯时，甲的第一句话是假的，第二句话是假的看似矛盾，但实际上这里的逻辑需要重新审视。正确的逻辑分析应该是：如果甲是罪犯，那么甲的两句话都是假的；乙的两句话都是真的；丙的两句话都是真的。这不符合条件。正确的解法是：甲是罪犯，因为当甲是罪犯时，甲的第一句话是假的，第二句话是假的；乙的第一句话是真的，第二句话是假的；丙的第一句话是真的，第二句话是真的。哦，我好像犯了一个错误。让我重新分析。如果甲是罪犯，那么甲的两句话都是假的；乙的第一句话是真的，第二句话是假的；丙的第一句话是真的，第二句话是真的（因为甲确实在说谎）。这不符合每个人说一句真话一句假话的条件。正确的罪犯应该是甲，因为经过仔细检查，只有甲作为罪犯时，乙和丙各说了一句真话和一句假话。',
                        lifeLesson: '复杂的逻辑谜题需要耐心和系统的分析，这在网络安全调查中尤为重要。',
                    },
                    {
                        content: '以下哪个逻辑推理形式是有效的？\n前提1：如果A，那么B\n前提2：非B\n结论：非A',
                        options: ['肯定前件', '否定后件', '肯定后件', '否定前件'],
                        correctIndex: 1,
                        explanation:
                            '这是逻辑学中的"否定后件"推理形式，是有效的。如果A导致B，而B不发生，那么A一定不成立。',
                        lifeLesson: '掌握基本的逻辑推理形式有助于你构建严密的论证，这在分析复杂的安全问题时非常有用。',
                    },
                    {
                        content:
                            '在一个数字推理游戏中，有四个数字：1, 2, 4, 8，它们分别对应字母A, B, C, D中的一个。已知：\n1. 如果1对应A，那么2对应B\n2. 如果2对应B，那么4对应C\n3. 如果4对应C，那么8对应D\n如果1不对应A，那么以下哪个结论一定正确？',
                        options: ['2不对应B', '4不对应C', '8不对应D', '以上都不一定正确'],
                        correctIndex: 3,
                        explanation:
                            '这些条件都是"如果...那么..."的形式，它们只告诉我们当前件为真时后件必须为真，但并没有说当前件为假时后件必须为假。所以如果1不对应A，我们无法确定其他对应关系。',
                        lifeLesson: '在逻辑推理中，理解条件命题的精确含义非常重要，不能随意进行反向推理。',
                    },
                ],
                successMessage:
                    '太棒了！你已经成为了一名出色的逻辑推理师。这种能力将帮助你在数字世界中破解各种复杂的谜题和挑战。',
            },
            {
                title: '网络安全专家',
                description: '作为一名成熟的Cyber侦探，你需要解决与网络安全相关的高级问题。',
                lifeGoal: '保护数字世界的安全是你的终极使命，现在你需要展现出专业的网络安全知识。',
                questions: [
                    {
                        content:
                            '一个黑客试图入侵系统，他需要输入一个4位数字的密码。已知密码的规则是：\n1. 所有数字都是不同的\n2. 数字从左到右依次递增\n3. 第二位数字是偶数\n4. 第四位数字是质数\n请问符合条件的密码有多少个？',
                        options: ['36', '42', '48', '54'],
                        correctIndex: 1,
                        explanation:
                            '根据条件，我们需要找到所有4位递增数列，其中第二位是偶数，第四位是质数。符合条件的质数有2,3,5,7，但由于数列递增且所有数字不同，第四位只能是3,5,7。通过组合计算，符合条件的密码共有42个。',
                        lifeLesson: '了解密码的安全规则对于保护系统免受黑客攻击至关重要。',
                    },
                    {
                        content: '在网络安全中，什么是"钓鱼攻击"？',
                        options: [
                            '通过物理接触获取信息的攻击',
                            '通过欺骗用户点击恶意链接获取信息的攻击',
                            '通过暴力破解密码的攻击',
                            '通过植入恶意软件的攻击',
                        ],
                        correctIndex: 1,
                        explanation:
                            '钓鱼攻击是一种社会工程学攻击，攻击者通过伪装成可信实体，欺骗用户点击恶意链接或提供敏感信息。',
                        lifeLesson: '了解常见的网络攻击方式是防范网络威胁的第一步。',
                    },
                    {
                        content: '以下哪种加密算法是对称加密算法？',
                        options: ['RSA', 'ECC', 'AES', 'SHA-256'],
                        correctIndex: 2,
                        explanation:
                            'AES是一种对称加密算法，使用相同的密钥进行加密和解密。RSA和ECC是不对称加密算法，SHA-256是哈希算法。',
                        lifeLesson: '理解不同类型的加密算法及其应用场景是网络安全专家的基本素养。',
                    },
                    {
                        content: '在信息安全中，什么是"零日漏洞"？',
                        options: [
                            '刚刚发现的系统漏洞',
                            '已经存在十年的系统漏洞',
                            '尚未被开发者修复的已知漏洞',
                            '已被修复但仍被利用的漏洞',
                        ],
                        correctIndex: 2,
                        explanation:
                            '零日漏洞是指软件或系统中存在的漏洞，已经被发现但尚未被开发者修复，攻击者可以利用这些漏洞进行攻击。',
                        lifeLesson: '及时更新软件和系统是防范零日漏洞攻击的重要措施。',
                    },
                    {
                        content:
                            '一个安全系统使用数字签名来验证消息的真实性。如果发送方使用私钥对消息进行签名，那么接收方应该使用什么来验证签名？',
                        options: ['发送方的私钥', '发送方的公钥', '接收方的私钥', '接收方的公钥'],
                        correctIndex: 1,
                        explanation:
                            '在非对称加密中，私钥用于签名，公钥用于验证签名。这确保了只有拥有私钥的发送方才能生成有效的签名，而任何人都可以使用公钥来验证签名的真实性。',
                        lifeLesson: '数字签名是确保电子通信安全的重要机制，在电子商务和网络安全中广泛应用。',
                    },
                ],
                successMessage:
                    '恭喜你成为了一名真正的网络安全专家！你已经掌握了网络安全的核心知识，这将帮助你在数字世界中守护信息安全。',
            },
            {
                title: '数据分析师',
                description: '作为一名资深的Cyber侦探，你需要具备数据分析能力，从海量数据中发现线索和异常。',
                lifeGoal: '培养敏锐的数据分析能力，从复杂的数据中洞察真相。',
                questions: [
                    {
                        content: '在数据分析中，什么是"异常值"？',
                        options: ['与其他数据点差异很大的数据点', '缺失的数据点', '重复的数据点', '错误的数据点'],
                        correctIndex: 0,
                        explanation:
                            '异常值是指数据集中与其他观测值有显著差异的数据点，可能是由于测量误差、数据录入错误或真正的异常现象导致的。',
                        lifeLesson: '识别异常值是数据分析的重要步骤，在网络安全中，异常值可能预示着潜在的安全威胁。',
                    },
                    {
                        content: '以下哪个统计指标可以用来描述数据的离散程度？',
                        options: ['平均数', '中位数', '标准差', '众数'],
                        correctIndex: 2,
                        explanation: '标准差是衡量数据离散程度的统计指标，表示数据点相对于平均值的分散程度。',
                        lifeLesson: '理解数据的离散程度有助于评估数据的稳定性和可靠性。',
                    },
                    {
                        content: '在大数据分析中，"数据挖掘"的主要目的是什么？',
                        options: ['收集更多的数据', '清洗和整理数据', '从数据中发现隐藏的模式和关联', '可视化数据'],
                        correctIndex: 2,
                        explanation:
                            '数据挖掘是指从大量数据中自动发现隐藏的模式、关联和趋势的过程，目的是提取有用的信息和知识。',
                        lifeLesson:
                            '数据挖掘技术在网络安全中有着广泛的应用，可以帮助发现网络攻击的模式和预测潜在的安全威胁。',
                    },
                    {
                        content:
                            '在一个包含10个数据点的数据集：1, 2, 3, 4, 5, 6, 7, 8, 9, 100中，哪个统计指标受异常值的影响最小？',
                        options: ['平均数', '标准差', '中位数', '极差'],
                        correctIndex: 2,
                        explanation:
                            '中位数是将数据按大小顺序排列后位于中间位置的数值，不受极端值的影响。而平均数、标准差和极差都会受到异常值的显著影响。',
                        lifeLesson:
                            '在处理包含异常值的数据时，选择适当的统计指标非常重要，中位数通常是比平均数更稳健的中心趋势度量。',
                    },
                    {
                        content:
                            '假设你正在分析一个网站的访问日志，发现某一天的访问量是前一天的10倍，但这些访问都来自同一个IP地址，并且没有任何实际的页面浏览。这最可能是什么情况？',
                        options: [
                            '网站突然变得非常受欢迎',
                            '搜索引擎爬虫在抓取网站',
                            '有人正在进行DDoS攻击',
                            '统计错误',
                        ],
                        correctIndex: 2,
                        explanation:
                            'DDoS（分布式拒绝服务）攻击是指攻击者通过大量请求淹没目标服务器，使其无法正常为合法用户提供服务。来自同一IP的大量无意义访问很可能是DDoS攻击的迹象。',
                        lifeLesson: '实时监控和分析网络流量是检测和防范DDoS攻击的重要手段。',
                    },
                ],
                successMessage:
                    '恭喜你成为了一名优秀的数据分析师！你已经掌握了数据分析的核心技能，这将帮助你在数字世界中从海量数据中发现重要线索和异常模式。',
            },
            {
                title: '人工智能侦探',
                description: '作为一名顶尖的Cyber侦探，你需要掌握人工智能技术，利用AI来辅助你的调查工作。',
                lifeGoal: '掌握人工智能技术，成为数字世界中最顶尖的侦探。',
                questions: [
                    {
                        content: '在机器学习中，什么是"监督学习"？',
                        options: [
                            '让计算机自主学习而不提供指导',
                            '使用标记数据来训练模型',
                            '通过奖惩机制来训练模型',
                            '模拟人类大脑的学习方式',
                        ],
                        correctIndex: 1,
                        explanation:
                            '监督学习是机器学习的一种方法，使用标记的训练数据（即包含输入和对应正确输出的数据）来训练模型，使其能够对新的、未见过的数据进行预测。',
                        lifeLesson:
                            '监督学习是人工智能在网络安全中应用最广泛的技术之一，可以用于检测异常、识别恶意软件等。',
                    },
                    {
                        content: '以下哪种算法属于无监督学习算法？',
                        options: ['线性回归', '决策树', 'K-means聚类', '支持向量机'],
                        correctIndex: 2,
                        explanation:
                            'K-means聚类是一种无监督学习算法，用于将相似的数据点分组到不同的簇中，而不需要预先标记的训练数据。',
                        lifeLesson: '无监督学习在网络安全中特别有用，可以帮助发现未知的攻击模式和异常行为。',
                    },
                    {
                        content: '在人工智能中，什么是"过拟合"？',
                        options: [
                            '模型在训练数据上表现不好',
                            '模型在训练数据上表现很好，但在新数据上表现很差',
                            '模型过于简单，无法捕捉数据中的模式',
                            '模型训练时间过长',
                        ],
                        correctIndex: 1,
                        explanation:
                            '过拟合是指模型过度学习训练数据中的细节和噪声，而不是数据中的一般模式，导致在新的、未见过的数据上表现不佳。',
                        lifeLesson:
                            '避免过拟合是构建有效机器学习模型的关键挑战之一，可以通过正则化、交叉验证等技术来缓解。',
                    },
                    {
                        content: '在网络安全中，人工智能可以用来检测恶意软件。以下哪种方法是AI检测恶意软件的常见方法？',
                        options: ['基于特征码的检测', '基于行为分析的检测', '基于规则的检测', '基于人工审查的检测'],
                        correctIndex: 1,
                        explanation:
                            '基于行为分析的检测是AI在恶意软件检测中的常见应用，通过分析软件的行为模式来识别潜在的恶意活动，而不仅仅依赖于已知的恶意软件特征码。',
                        lifeLesson: 'AI技术正在改变网络安全的格局，使我们能够更有效地检测和防范日益复杂的网络威胁。',
                    },
                    {
                        content:
                            '假设你训练了一个机器学习模型来检测网络入侵，在测试集上的准确率达到了99%。但在实际部署后，发现该模型经常将正常流量误判为入侵。这最可能是什么原因？',
                        options: ['训练数据不足', '模型过拟合', '测试集与实际数据分布不同', '模型复杂度不够'],
                        correctIndex: 2,
                        explanation:
                            '如果测试集与实际部署环境中的数据分布不同，那么模型在测试集上的良好表现可能无法在实际应用中重现，这被称为"分布漂移"问题。',
                        lifeLesson: '在将AI模型部署到实际环境之前，确保测试数据能够代表真实数据的分布是非常重要的。',
                    },
                ],
                successMessage:
                    '恭喜你成为了一名真正的人工智能侦探！你已经掌握了人工智能的核心知识和应用方法，这将帮助你在数字世界中更高效地解决复杂的安全问题和谜题。你已经完成了所有的Cyber侦探挑战，展现了卓越的数字分析能力、逻辑推理能力和技术素养。现在，你准备好迎接更重要的使命了吗？',
            },
        ],
        achievements: {
            level1: {
                name: '数字入门者',
                description: '成功完成了数字初入者关卡，初步掌握了数字规律识别能力。',
                icon: '🔢',
            },
            level2: {
                name: '逻辑推理师',
                description: '成为了一名出色的逻辑推理师，能够解决复杂的逻辑谜题。',
                icon: '🧩',
            },
            final: {
                name: '网络安全大师',
                description: '成功通过了所有数字安全挑战，成为了一名真正的网络安全专家！',
                icon: '🧠',
            },
        },
    },

    // 非遗守护人角色
    heritage: {
        name: '非遗守护人',
        tagline: '传承中华文化的守护者',
        description:
            '你将成为一名致力于保护和传承中国非物质文化遗产的守护者，通过了解各种传统技艺和文化知识，来完成守护任务。',
        story: [
            {
                text: '作为一名年轻的非遗守护人，你肩负着传承和保护中华文化瑰宝的重任。今天，你接到了一个新的任务，需要验证一批非物质文化遗产项目的真实性和价值。',
                next: true,
            },
            {
                text: '为了完成这个任务，你需要通过一系列关于中国传统文化和非物质文化遗产的考验。每通过一个考验，你就能获得更多关于如何保护这些文化瑰宝的知识和技能。',
                next: true,
            },
            {
                text: '现在，准备好接受第一个文化知识的挑战了吗？这将是你成为杰出非遗守护人的第一步！',
                next: true,
                startBattle: true,
            },
        ],
        levels: [
            {
                title: '文化启蒙者',
                description: '作为一名非遗守护人的初学者，你需要先了解中国传统文化的基础知识。',
                lifeGoal: '要成为优秀的文化守护者，首先要深入了解传统文化的根基。',
                questions: [
                    {
                        content: '中国传统书法有五种主要字体，以下哪种不属于这五种主要字体？',
                        options: ['篆书', '隶书', '楷书', '瘦金体'],
                        correctIndex: 3,
                        explanation:
                            '中国传统书法的五种主要字体是：篆书、隶书、楷书、行书和草书。瘦金体是宋徽宗赵佶所创的一种字体，属于楷书的变体，但不是五种主要字体之一。',
                        lifeLesson: '了解书法字体的演变是理解中国传统文化的重要一步。',
                    },
                    {
                        content: '中国传统绘画中的"四君子"指的是哪四种植物？',
                        options: ['梅、兰、竹、菊', '松、竹、梅、菊', '梅、兰、菊、荷', '松、竹、兰、菊'],
                        correctIndex: 0,
                        explanation:
                            '"四君子"是中国传统绘画中常用的题材，指的是梅花、兰花、竹子和菊花，这四种植物分别象征着坚韧、高洁、正直和隐逸的品质。',
                        lifeLesson: '中国传统绘画不仅是艺术表现，更是文化精神的载体。',
                    },
                    {
                        content: '以下哪个是中国古代儒家经典"四书"之一？',
                        options: ['《易经》', '《道德经》', '《论语》', '《史记》'],
                        correctIndex: 2,
                        explanation:
                            '儒家经典"四书"包括《论语》、《孟子》、《大学》和《中庸》。《易经》属于"五经"之一，《道德经》是道家经典，《史记》是史学著作。',
                        lifeLesson:
                            '儒家思想是中国传统文化的重要组成部分，了解儒家经典有助于理解中国传统文化的核心价值观。',
                    },
                    {
                        content: '中国传统建筑中，"斗拱"的主要作用是什么？',
                        options: ['装饰', '承重', '分隔空间', '防水'],
                        correctIndex: 1,
                        explanation:
                            '斗拱是中国传统建筑特有的结构构件，主要作用是承重，将屋顶的重量传递到柱子上，同时也具有装饰作用。',
                        lifeLesson: '中国传统建筑蕴含着丰富的科学原理和美学思想，是中华文化的重要载体。',
                    },
                    {
                        content: '以下哪个节气标志着春季的开始？',
                        options: ['立春', '春分', '雨水', '惊蛰'],
                        correctIndex: 0,
                        explanation:
                            '立春是二十四节气中的第一个节气，标志着春季的开始。春分是春季的中点，雨水和惊蛰是立春后的两个节气。',
                        lifeLesson: '二十四节气是中国古代劳动人民智慧的结晶，反映了中国传统的时间观念和农耕文化。',
                    },
                ],
                successMessage:
                    '恭喜你完成了文化启蒙者关卡！你已经掌握了中国传统文化的基础知识，这将帮助你更好地理解和传承非物质文化遗产。',
            },
            {
                title: '传统节日守护者',
                description: '节日是文化传承的重要载体，你需要深入了解中国传统节日的内涵。',
                lifeGoal: '保护传统节日文化，让古老的习俗在现代社会焕发新的活力。',
                questions: [
                    {
                        content: '中国传统节日中，哪个节日与牛郎织女的传说有关？',
                        options: ['春节', '元宵节', '七夕节', '中秋节'],
                        correctIndex: 2,
                        explanation:
                            '七夕节，又称乞巧节，是中国传统节日中最具浪漫色彩的节日，与牛郎织女的传说密切相关。传说每年农历七月初七，牛郎织女会在鹊桥相会。',
                        lifeLesson: '传统节日承载着丰富的文化内涵和民间传说，是中华文化的重要组成部分。',
                    },
                    {
                        content: '以下哪个习俗是春节期间的传统活动？',
                        options: ['赏月', '赛龙舟', '贴春联', '吃月饼'],
                        correctIndex: 2,
                        explanation:
                            '贴春联是春节期间的传统习俗，人们通过贴春联来表达对新年的美好祝愿。赏月和吃月饼是中秋节的习俗，赛龙舟是端午节的习俗。',
                        lifeLesson:
                            '传统习俗是节日文化的重要体现，通过参与这些习俗，我们可以更好地感受和传承传统文化。',
                    },
                    {
                        content: '端午节是为了纪念哪位历史人物？',
                        options: ['孔子', '屈原', '李白', '关羽'],
                        correctIndex: 1,
                        explanation:
                            '端午节是为了纪念战国时期的爱国诗人屈原，他在农历五月初五投汨罗江自尽，后人为了纪念他，形成了端午节的各种习俗。',
                        lifeLesson:
                            '许多传统节日都与历史人物和事件有关，了解这些背景有助于我们更深入地理解节日的文化内涵。',
                    },
                    {
                        content: '中秋节的传统食物是什么？',
                        options: ['饺子', '粽子', '月饼', '汤圆'],
                        correctIndex: 2,
                        explanation:
                            '月饼是中秋节的传统食物，象征着团圆和美满。饺子是春节的传统食物，粽子是端午节的传统食物，汤圆是元宵节的传统食物。',
                        lifeLesson: '传统食物是节日文化的重要组成部分，每一种食物都有其独特的文化寓意。',
                    },
                    {
                        content: '农历正月十五是什么节日？',
                        options: ['春节', '元宵节', '清明节', '端午节'],
                        correctIndex: 1,
                        explanation:
                            '农历正月十五是元宵节，也称为上元节，是春节之后的第一个重要节日，人们通常会赏花灯、吃汤圆。',
                        lifeLesson: '元宵节是中国传统节日中最热闹的节日之一，象征着团圆和美满。',
                    },
                ],
                successMessage:
                    '太棒了！你已经成为了一名合格的传统节日守护者。通过了解传统节日的文化内涵，你将更好地保护和传承这些宝贵的文化遗产。',
            },
            {
                title: '传统技艺传承者',
                description: '传统技艺是中华文化的瑰宝，作为一名非遗守护人，你需要深入了解这些精湛的传统技艺。',
                lifeGoal: '传承和保护传统技艺，让古老的工艺在现代社会焕发新的生机。',
                questions: [
                    {
                        content: '中国传统工艺中，被誉为"东方艺术明珠"的是哪种工艺？',
                        options: ['景德镇瓷器', '苏州刺绣', '景泰蓝', '玉雕'],
                        correctIndex: 2,
                        explanation:
                            '景泰蓝，又称"铜胎掐丝珐琅"，是中国传统工艺美术的珍品，以其精湛的工艺、绚丽的色彩和独特的艺术风格，被誉为"东方艺术明珠"。',
                        lifeLesson: '传统工艺凝聚了古代匠人的智慧和创造力，保护这些技艺是我们的责任。',
                    },
                    {
                        content: '以下哪种传统工艺以"四大名绣"之一著称？',
                        options: ['苏绣', '湘绣', '粤绣', '蜀绣', '以上都是'],
                        correctIndex: 4,
                        explanation:
                            '苏绣、湘绣、粤绣和蜀绣被称为中国"四大名绣"，各具特色，代表了中国传统刺绣工艺的最高水平。',
                        lifeLesson: '中国传统刺绣工艺历史悠久，技艺精湛，是中华文化的重要组成部分。',
                    },
                    {
                        content: '中国传统木雕工艺中，以下哪个地区以"东阳木雕"著称？',
                        options: ['浙江', '福建', '广东', '安徽'],
                        correctIndex: 0,
                        explanation:
                            '东阳木雕是浙江东阳地区的传统木雕工艺，以其精湛的雕刻技艺和独特的艺术风格著称，被誉为"中国木雕之乡"。',
                        lifeLesson: '不同地区的传统工艺往往具有鲜明的地方特色，反映了当地的文化传统和审美观念。',
                    },
                    {
                        content: '以下哪种传统工艺与"文房四宝"有关？',
                        options: ['宣纸制作', '剪纸', '皮影戏', '糖画'],
                        correctIndex: 0,
                        explanation:
                            '宣纸是中国传统的书写和绘画用纸，与笔、墨、砚并称为"文房四宝"。宣纸制作工艺是中国重要的非物质文化遗产。',
                        lifeLesson: '文房四宝是中国传统文人书房中必备的文具，也是中国传统文化的重要象征。',
                    },
                    {
                        content: '以下哪种传统工艺被称为"活的剪纸"？',
                        options: ['皮影戏', '风筝', '面塑', '蜡染'],
                        correctIndex: 0,
                        explanation:
                            '皮影戏是一种以兽皮或纸板做成的人物剪影以表演故事的民间戏剧，其人物造型和表演方式类似于剪纸艺术，因此被称为"活的剪纸"。',
                        lifeLesson: '传统工艺之间往往相互影响、相互借鉴，共同构成了丰富多彩的中华文化。',
                    },
                ],
                successMessage:
                    '恭喜你成为了一名优秀的传统技艺传承者！你已经深入了解了中国传统工艺的精湛技艺和文化内涵，这将帮助你更好地传承和保护这些宝贵的非物质文化遗产。',
            },
            {
                title: '传统戏曲鉴赏家',
                description: '中国传统戏曲是世界文化遗产的瑰宝，作为一名非遗守护人，你需要掌握传统戏曲的专业知识。',
                lifeGoal: '传承和弘扬传统戏曲文化，让古老的艺术形式在现代社会继续发扬光大。',
                questions: [
                    {
                        content: '中国传统戏曲中，京剧的"四大名旦"是指哪四位艺术家？',
                        options: [
                            '梅兰芳、程砚秋、尚小云、荀慧生',
                            '梅兰芳、周信芳、马连良、谭富英',
                            '程砚秋、尚小云、荀慧生、张君秋',
                            '梅兰芳、程砚秋、马连良、荀慧生',
                        ],
                        correctIndex: 0,
                        explanation:
                            '京剧的"四大名旦"是指二十世纪二、三十年代活跃在中国京剧舞台上的四位杰出的旦角表演艺术家：梅兰芳、程砚秋、尚小云和荀慧生。',
                        lifeLesson: '传统戏曲是中华文化的瑰宝，了解其代表人物和艺术特色对于传承至关重要。',
                    },
                    {
                        content: '以下哪个剧种被称为"中国戏曲之母"？',
                        options: ['京剧', '昆曲', '豫剧', '粤剧'],
                        correctIndex: 1,
                        explanation:
                            '昆曲是中国最古老的戏曲剧种之一，被誉为"中国戏曲之母"，对京剧等其他戏曲剧种的形成和发展产生了深远影响。',
                        lifeLesson:
                            '昆曲是中国传统文化的重要组成部分，2001年被联合国教科文组织列为"人类口述和非物质遗产代表作"。',
                    },
                    {
                        content: '京剧的"生、旦、净、丑"分别指的是什么？',
                        options: ['角色行当', '表演技巧', '服装样式', '唱腔流派'],
                        correctIndex: 0,
                        explanation:
                            '"生、旦、净、丑"是京剧的四大角色行当，分别代表不同类型的人物形象。生行是男性角色，旦行是女性角色，净行俗称花脸，丑行是喜剧角色。',
                        lifeLesson: '角色行当是传统戏曲的重要特征，不同的行当有其独特的表演程式和艺术风格。',
                    },
                    {
                        content: '以下哪个是豫剧的代表剧目？',
                        options: ['《霸王别姬》', '《花木兰》', '《天仙配》', '《白蛇传》'],
                        correctIndex: 1,
                        explanation:
                            '《花木兰》是豫剧的经典剧目，讲述了花木兰代父从军的故事，由豫剧表演艺术家常香玉主演而闻名。',
                        lifeLesson: '不同的戏曲剧种往往有其代表性的剧目，这些剧目反映了当地的文化传统和审美观念。',
                    },
                    {
                        content: '传统戏曲中的"脸谱"主要用于哪个行当？',
                        options: ['生', '旦', '净', '丑'],
                        correctIndex: 2,
                        explanation:
                            '脸谱是传统戏曲中净行（花脸）的重要特征，通过不同的色彩和图案来表现人物的性格和品质。',
                        lifeLesson: '脸谱艺术是中国传统戏曲的重要组成部分，具有独特的审美价值和文化内涵。',
                    },
                ],
                successMessage:
                    '恭喜你成为了一名出色的传统戏曲鉴赏家！你已经掌握了中国传统戏曲的专业知识，这将帮助你更好地理解和传承这一宝贵的非物质文化遗产。',
            },
            {
                title: '非遗传承大师',
                description: '作为一名顶尖的非遗守护人，你需要全面掌握非物质文化遗产的保护和传承知识。',
                lifeGoal: '成为非物质文化遗产的守护者和传承者，让中华文化的瑰宝永远流传下去。',
                questions: [
                    {
                        content: '联合国教科文组织设立的"人类非物质文化遗产代表作名录"是从哪一年开始评选的？',
                        options: ['1999年', '2001年', '2003年', '2005年'],
                        correctIndex: 1,
                        explanation:
                            '联合国教科文组织于2001年开始评选"人类非物质文化遗产代表作名录"，旨在保护和传承全球范围内的非物质文化遗产。',
                        lifeLesson: '非物质文化遗产的保护是全人类共同的责任，需要国际社会的共同努力。',
                    },
                    {
                        content: '以下哪项不属于非物质文化遗产的范畴？',
                        options: ['传统技艺', '民俗活动', '古建筑', '口头传说'],
                        correctIndex: 2,
                        explanation:
                            '非物质文化遗产是指各种以非物质形态存在的与群众生活密切相关、世代相承的传统文化表现形式，包括口头传统、传统表演艺术、民俗活动和礼仪与节庆、有关自然界和宇宙的民间传统知识和实践、传统手工艺技能等。古建筑属于物质文化遗产。',
                        lifeLesson: '了解非物质文化遗产的定义和范畴，有助于我们更好地保护和传承这些宝贵的文化遗产。',
                    },
                    {
                        content: '中国第一个入选"人类非物质文化遗产代表作名录"的项目是什么？',
                        options: ['昆曲', '京剧', '古琴艺术', '端午节'],
                        correctIndex: 0,
                        explanation:
                            '2001年，昆曲成为中国第一个入选"人类非物质文化遗产代表作名录"的项目，开启了中国非物质文化遗产保护的新篇章。',
                        lifeLesson:
                            '昆曲作为中国最古老的戏曲剧种之一，具有极高的历史价值和艺术价值，是中华文化的重要象征。',
                    },
                    {
                        content: '以下哪种方法是保护非物质文化遗产的有效途径？',
                        options: ['记录和保存', '商业化开发', '现代化改造', '以上都是'],
                        correctIndex: 0,
                        explanation:
                            '记录和保存是非物质文化遗产保护的基础，通过文字、录音、录像等方式将非物质文化遗产记录下来，为后人留下宝贵的资料。商业化开发和现代化改造需要谨慎进行，避免对非物质文化遗产的本质造成破坏。',
                        lifeLesson:
                            '非物质文化遗产的保护需要采取科学合理的方法，在保护其本质特征的前提下，探索其在现代社会中的传承和发展。',
                    },
                    {
                        content: '作为一名非遗守护人，以下哪种态度是正确的？',
                        options: [
                            '认为传统的就是过时的，应该被淘汰',
                            '认为传统的都是最好的，必须原封不动地保留',
                            '尊重传统，同时探索传统在现代社会中的创新发展',
                            '对传统不感兴趣，专注于现代文化',
                        ],
                        correctIndex: 2,
                        explanation:
                            '正确的态度应该是尊重传统，认识到非物质文化遗产的价值，同时也要看到传统需要在现代社会中找到新的生存和发展空间，通过创新来延续其生命力。',
                        lifeLesson:
                            '非物质文化遗产的保护不是简单的保存，而是在传承中创新，在创新中传承，让古老的文化在现代社会中焕发新的生机。',
                    },
                ],
                successMessage:
                    '恭喜你成为了一名真正的非遗传承大师！你已经完成了所有的非物质文化遗产知识考验，展现了对中华文化的深刻理解和保护传承的决心。现在，你准备好肩负起传承和保护中华文化瑰宝的重任了吗？',
            },
        ],
        achievements: {
            level1: {
                name: '文化启蒙者',
                description: '成功完成了文化启蒙者关卡，初步掌握了中国传统文化的基础知识。',
                icon: '📚',
            },
            level2: {
                name: '节日守护者',
                description: '深入了解了中国传统节日的文化内涵，成为了一名合格的节日守护者。',
                icon: '🎎',
            },
            final: {
                name: '非遗传承大师',
                description: '成功通过了所有传统文化知识的考验，成为了一名真正的非遗传承大师！',
                icon: '🏮',
            },
        },
    },

    // 星球开拓者角色
    space: {
        name: '星球开拓者',
        tagline: '探索宇宙奥秘的先锋',
        description:
            '你将成为一名勇敢的星际开拓者，探索遥远的星球和宇宙奥秘，通过解决各种科学问题来完成你的星际探索任务。',
        story: [
            {
                text: '作为一名年轻的星球开拓者，你被选中参加一项激动人心的星际探索任务。你的目标是探索一个未知的星系，寻找适合人类居住的新家园，并收集关于宇宙的宝贵数据。',
                next: true,
            },
            {
                text: '在这次探索任务中，你将面临各种科学挑战和宇宙谜题。每解决一个问题，你就能更深入地了解宇宙的奥秘，为人类的星际移民计划做出贡献。',
                next: true,
            },
            {
                text: '现在，准备好接受第一个宇宙知识的挑战了吗？这将是你成为传奇星球开拓者的第一步！',
                next: true,
                startBattle: true,
            },
        ],
        levels: [
            {
                title: '太阳系探索者',
                description: '作为一名新手星球开拓者，你需要先了解我们所在的太阳系的基础知识。',
                lifeGoal: '探索宇宙的旅程，从了解我们的太阳系开始。',
                questions: [
                    {
                        content: '在太阳系中，哪个行星被称为"红色星球"？',
                        options: ['金星', '火星', '木星', '土星'],
                        correctIndex: 1,
                        explanation:
                            '火星被称为"红色星球"，这是因为火星表面富含氧化铁（铁锈），使得它呈现出独特的红色外观。',
                        lifeLesson: '了解太阳系中的行星特征是成为优秀星际探索者的第一步。',
                    },
                    {
                        content: '太阳系中最大的行星是哪一个？',
                        options: ['地球', '土星', '木星', '天王星'],
                        correctIndex: 2,
                        explanation:
                            '木星是太阳系中最大的行星，其直径约为地球的11倍，质量约为其他所有行星质量总和的2.5倍。',
                        lifeLesson: '太阳系中的行星各具特色，了解它们的大小和结构有助于我们更好地理解宇宙。',
                    },
                    {
                        content: '地球的卫星是什么？',
                        options: ['金星', '火星', '月球', '木星'],
                        correctIndex: 2,
                        explanation: '月球是地球唯一的天然卫星，它围绕地球运行，对地球的潮汐现象产生重要影响。',
                        lifeLesson: '卫星是行星的重要组成部分，研究卫星可以帮助我们更好地了解行星的形成和演化。',
                    },
                    {
                        content: '太阳系中哪颗行星被称为"地球的孪生姐妹"？',
                        options: ['金星', '火星', '土星', '木星'],
                        correctIndex: 0,
                        explanation:
                            '金星被称为"地球的孪生姐妹"，因为它的大小、质量和密度都与地球相似，但表面环境却极为恶劣。',
                        lifeLesson: '即使看起来相似的天体，其内部结构和表面环境也可能有很大的差异。',
                    },
                    {
                        content: '太阳系中距离太阳最远的行星是哪一颗？',
                        options: ['土星', '天王星', '海王星', '冥王星'],
                        correctIndex: 2,
                        explanation: '海王星是太阳系中距离太阳最远的行星，冥王星在2006年被重新分类为矮行星。',
                        lifeLesson: '我们对太阳系的认识是不断发展和完善的，科学探索永无止境。',
                    },
                ],
                successMessage:
                    '恭喜你完成了太阳系探索者关卡！你已经掌握了太阳系的基础知识，这将帮助你在未来的星际探索中更好地理解宇宙的奥秘。',
            },
            {
                title: '宇宙测量师',
                description: '要成为一名出色的星球开拓者，你需要掌握宇宙测量的基本单位和方法。',
                lifeGoal: '准确测量宇宙中的距离和时间，是探索宇宙的基础技能。',
                questions: [
                    {
                        content: '光年是什么单位？',
                        options: ['时间单位', '距离单位', '速度单位', '质量单位'],
                        correctIndex: 1,
                        explanation: '光年是一个距离单位，指的是光在真空中一年内传播的距离，约为9.46万亿公里。',
                        lifeLesson: '在宇宙尺度上，我们需要特殊的单位来测量巨大的距离。',
                    },
                    {
                        content: '以下哪种天体被称为"宇宙中的灯塔"，可以帮助天文学家测量宇宙距离？',
                        options: ['恒星', '行星', '超新星', '造父变星'],
                        correctIndex: 3,
                        explanation:
                            '造父变星是一种特殊的变星，其亮度变化周期与其真实亮度之间存在确定的关系。天文学家可以利用这一关系来测量造父变星的距离，因此它们被称为"宇宙中的灯塔"。',
                        lifeLesson: '天文学家使用各种巧妙的方法来测量宇宙中的距离，造父变星是其中重要的工具之一。',
                    },
                    {
                        content: '银河系的直径大约是多少光年？',
                        options: ['10,000光年', '100,000光年', '1,000,000光年', '10,000,000光年'],
                        correctIndex: 1,
                        explanation:
                            '银河系的直径大约为10万光年，这意味着光从银河系的一端传播到另一端需要大约10万年的时间。',
                        lifeLesson: '宇宙的尺度远远超出我们的日常经验，需要我们用新的思维方式来理解。',
                    },
                    {
                        content: '地球到太阳的平均距离被称为什么单位？',
                        options: ['天文单位', '光年', '秒差距', '公里'],
                        correctIndex: 0,
                        explanation:
                            '地球到太阳的平均距离被称为一个天文单位（AU），约等于1.5亿公里，是天文学中常用的距离单位。',
                        lifeLesson: '在不同的尺度上，我们需要使用不同的测量单位来方便地描述距离。',
                    },
                    {
                        content: '哈勃定律告诉我们什么？',
                        options: ['宇宙在膨胀', '宇宙在收缩', '宇宙是静止的', '宇宙是无限的'],
                        correctIndex: 0,
                        explanation: '哈勃定律表明，星系离我们越远，其远离我们的速度就越快，这是宇宙膨胀的重要证据。',
                        lifeLesson: '现代天文学的发现不断刷新我们对宇宙的认识，推动着科学的进步。',
                    },
                ],
                successMessage:
                    '太棒了！你已经成为了一名合格的宇宙测量师。掌握宇宙测量的方法将帮助你在星际探索中准确定位和导航。',
            },
            {
                title: '黑洞探险家',
                description: '作为一名成熟的星球开拓者，你需要探索宇宙中最神秘的天体——黑洞。',
                lifeGoal: '探索宇宙中最极端的物理现象，是勇敢的星球开拓者的终极挑战。',
                questions: [
                    {
                        content: '黑洞的逃逸速度大于什么？',
                        options: ['地球的逃逸速度', '太阳的逃逸速度', '光速', '声速'],
                        correctIndex: 2,
                        explanation:
                            '黑洞的引力非常强大，以至于其逃逸速度大于光速。这意味着连光都无法从黑洞中逃逸出来，因此黑洞是"黑"的。',
                        lifeLesson: '黑洞是宇宙中最极端的天体之一，挑战着我们对物理规律的理解。',
                    },
                    {
                        content: '黑洞的边界被称为什么？',
                        options: ['事件视界', '奇点', '视界边缘', '黑洞表面'],
                        correctIndex: 0,
                        explanation:
                            '事件视界是黑洞的边界，一旦物体越过事件视界，就再也无法逃脱黑洞的引力，包括光在内。',
                        lifeLesson: '事件视界是黑洞最显著的特征之一，它标志着我们对黑洞内部了解的极限。',
                    },
                    {
                        content: '根据爱因斯坦的广义相对论，黑洞是如何形成的？',
                        options: ['恒星死亡后坍缩形成', '宇宙大爆炸时直接形成', '暗物质聚集形成', '外星文明创造'],
                        correctIndex: 0,
                        explanation: '当质量足够大的恒星耗尽核燃料后，会发生引力坍缩，最终形成黑洞。',
                        lifeLesson: '黑洞的形成是恒星演化的最终阶段之一，体现了宇宙中物质和能量的转化过程。',
                    },
                    {
                        content: '黑洞会"蒸发"吗？',
                        options: ['不会，黑洞只会不断吞噬物质', '会，通过霍金辐射', '不确定', '只有小黑洞会蒸发'],
                        correctIndex: 1,
                        explanation:
                            '根据霍金辐射理论，黑洞会通过量子效应向外辐射粒子，最终导致黑洞"蒸发"，不过这一过程极其缓慢。',
                        lifeLesson: '黑洞并不是完全"黑"的，它也会与周围环境发生相互作用。',
                    },
                    {
                        content: '银河系中心是否存在超大质量黑洞？',
                        options: ['是', '否', '不确定', '可能存在但未被证实'],
                        correctIndex: 0,
                        explanation:
                            '科学家通过观测银河系中心恒星的运动轨迹，已经证实银河系中心存在一个质量约为400万个太阳质量的超大质量黑洞，被称为人马座A*。',
                        lifeLesson: '超大质量黑洞可能存在于大多数星系的中心，对星系的形成和演化产生重要影响。',
                    },
                ],
                successMessage:
                    '恭喜你成为了一名真正的黑洞探险家！你已经掌握了黑洞的基本知识，这将帮助你在星际探索中应对宇宙中最极端的物理现象。',
            },
            {
                title: '星际农业专家',
                description: '作为一名资深的星球开拓者，你需要探索在太空和其他星球上进行农业生产的可能性。',
                lifeGoal: '解决人类星际移民中的食物问题，是实现长期太空探索的关键。',
                questions: [
                    {
                        content: '在太空中种植植物面临的最大挑战是什么？',
                        options: ['重力缺失', '辐射', '温度控制', '所有以上因素'],
                        correctIndex: 3,
                        explanation:
                            '在太空中种植植物需要解决重力缺失、宇宙辐射、温度控制、光照、空气和水等多个方面的问题，是一项复杂的系统工程。',
                        lifeLesson: '在极端环境中生存和发展，需要我们创造性地解决各种问题。',
                    },
                    {
                        content: '以下哪种植物最适合在太空环境中种植？',
                        options: ['水稻', '小麦', '生菜', '玉米'],
                        correctIndex: 2,
                        explanation:
                            '生菜等叶菜类植物生长周期短、占用空间小、营养价值高，相对更容易在太空环境中种植，已经在国际空间站上成功种植。',
                        lifeLesson: '选择适合的作物是太空农业成功的关键之一。',
                    },
                    {
                        content: '太空种植中，植物的根通常向哪个方向生长？',
                        options: ['向下', '向上', '随机方向', '向营养物质方向'],
                        correctIndex: 3,
                        explanation:
                            '在失重环境中，植物的根不再受到重力的引导，而是会向营养物质和水分丰富的方向生长，这种现象被称为向化性。',
                        lifeLesson: '生物会通过各种方式适应环境的变化，展现出惊人的生命力和适应性。',
                    },
                    {
                        content: '在火星上种植植物，需要解决的首要问题是什么？',
                        options: ['火星土壤毒性', '极端温度', '低气压', '辐射'],
                        correctIndex: 0,
                        explanation:
                            '火星土壤中含有高浓度的有毒物质，如高氯酸盐，对植物生长极为不利，需要进行处理或使用人工土壤。',
                        lifeLesson: '在进行外星殖民前，我们需要充分了解目标星球的环境特点，并找到相应的解决方案。',
                    },
                    {
                        content: '太空农业的主要目的是什么？',
                        options: ['提供食物', '提供氧气', '循环利用废物', '所有以上目的'],
                        correctIndex: 3,
                        explanation:
                            '太空农业不仅可以为宇航员提供新鲜食物，还可以通过光合作用产生氧气，同时通过植物吸收和微生物分解来循环利用废物，是太空生态系统的重要组成部分。',
                        lifeLesson: '建立封闭的生态循环系统是实现长期太空探索和外星殖民的基础。',
                    },
                ],
                successMessage:
                    '恭喜你成为了一名出色的星际农业专家！你已经掌握了在太空和其他星球上进行农业生产的关键知识，这将为人类的星际移民计划奠定重要基础。',
            },
            {
                title: '外星资源勘探者',
                description:
                    '作为一名顶级的星球开拓者，你需要学习如何勘探和利用外星资源，为人类的星际殖民提供物质基础。',
                lifeGoal: '发现和利用外星资源，是实现可持续星际探索的重要保障。',
                questions: [
                    {
                        content: '月球上最有价值的资源是什么？',
                        options: ['水冰', '矿产资源', '太阳能', '所有以上资源'],
                        correctIndex: 3,
                        explanation:
                            '月球上的水冰可以分解为氢气和氧气，用于呼吸和火箭燃料；矿产资源如氦-3是潜在的核聚变燃料；月球表面的太阳能资源也非常丰富。',
                        lifeLesson: '不同的外星环境蕴含着不同的资源，需要我们有针对性地进行勘探和开发。',
                    },
                    {
                        content: '小行星带中最常见的资源是什么？',
                        options: ['金属矿产', '水', '有机物质', '稀有气体'],
                        correctIndex: 0,
                        explanation:
                            '小行星带中的小行星主要由岩石和金属组成，富含铁、镍、铂等金属矿产，是未来太空采矿的重要目标。',
                        lifeLesson: '小行星带是太阳系中重要的资源宝库，开发小行星资源将为人类的太空探索提供物质支持。',
                    },
                    {
                        content: '在火星上，水主要以什么形式存在？',
                        options: ['液态水', '水蒸气', '冰', '矿物结合水'],
                        correctIndex: 2,
                        explanation:
                            '由于火星表面温度低、气压低，水无法以液态形式长期存在，主要以冰的形式存在于两极和地下。',
                        lifeLesson: '了解目标星球上水资源的分布和存在形式，对于实现外星殖民至关重要。',
                    },
                    {
                        content: '太空采矿面临的主要技术挑战是什么？',
                        options: ['低重力环境作业', '远程操作', '资源运输', '所有以上挑战'],
                        correctIndex: 3,
                        explanation:
                            '太空采矿需要解决低重力环境下的作业、远程控制和自动化、资源的加工和运输等多个技术难题，是一项复杂的系统工程。',
                        lifeLesson: '技术创新是推动太空探索和资源开发的核心动力。',
                    },
                    {
                        content: '开发外星资源对人类有什么重要意义？',
                        options: ['减轻地球资源压力', '支持太空探索和殖民', '促进科技发展', '所有以上意义'],
                        correctIndex: 3,
                        explanation:
                            '开发外星资源不仅可以减轻地球的资源压力，还可以为太空探索和殖民提供物质支持，同时促进相关技术的发展和创新。',
                        lifeLesson: '探索和开发宇宙资源是人类文明可持续发展的重要方向。',
                    },
                ],
                successMessage:
                    '恭喜你成为了一名卓越的外星资源勘探者！你已经掌握了勘探和利用外星资源的专业知识，这将为人类的星际探索和殖民计划提供重要的物质保障。现在，你准备好带领人类开启宇宙资源开发的新篇章了吗？',
            },
        ],
        achievements: {
            level1: {
                name: '太阳系探索者',
                description: '成功完成了太阳系探索者关卡，初步掌握了太阳系的基础知识。',
                icon: '🪐',
            },
            level2: {
                name: '宇宙测量师',
                description: '掌握了宇宙测量的基本单位和方法，成为了一名合格的宇宙测量师。',
                icon: '📏',
            },
            final: {
                name: '星际探索大师',
                description: '成功完成了所有宇宙知识的挑战，成为了一名真正的星际探索大师！',
                icon: '🚀',
            },
        },
    },

    // 数学探索家角色
    math: {
        name: '数学探索家',
        tagline: '用数学思维探索世界的奥秘',
        description: '你将成为一名热爱数学的探索家，通过解决各种数学问题，揭示隐藏在数字背后的规律和美丽。',
        story: [
            {
                text: '作为一名年轻的数学探索家，你对数字世界充满了好奇。今天，你发现了一本古老的数学手稿，上面记载着一系列富有挑战性的数学问题，这些问题据说能够帮助人们更好地理解数学的本质。',
                next: true,
            },
            {
                text: '为了解开这些数学谜题，你需要运用你的数学知识和思维能力。每解决一个问题，你就能更深入地理解数学的奥秘，发现数字世界的美丽和规律。',
                next: true,
            },
            {
                text: '现在，准备好接受第一个数学挑战了吗？这将是你成为杰出数学探索家的第一步！',
                next: true,
                startBattle: true,
            },
        ],
        levels: [
            {
                title: '数列探索者',
                description: '作为一名数学探索家，你需要先掌握数列的基本规律，这是理解数学世界的重要基础。',
                lifeGoal: '发现数字背后的规律，是开启数学探索之旅的钥匙。',
                questions: [
                    {
                        content:
                            '在数学中，斐波那契数列的前两项是0和1，之后的每一项都是前两项之和。请问斐波那契数列的第10项是多少？',
                        options: ['21', '34', '55', '89'],
                        correctIndex: 1,
                        explanation: '斐波那契数列前10项依次是：0, 1, 1, 2, 3, 5, 8, 13, 21, 34。所以第10项是34。',
                        lifeLesson: '数列规律在自然界和生活中无处不在，掌握它们能帮助我们更好地理解世界的运行方式。',
                    },
                    {
                        content: '以下哪个数学常数的值约为3.14159？',
                        options: ['e', 'φ', 'π', 'γ'],
                        correctIndex: 2,
                        explanation: 'π（圆周率）是一个数学常数，表示圆的周长与直径的比值，其近似值为3.14159。',
                        lifeLesson: '数学常数是数学世界的基石，它们连接着不同的数学领域，展现了数学的统一之美。',
                    },
                    {
                        content: '等差数列1, 4, 7, 10, ...的第20项是多少？',
                        options: ['55', '58', '61', '64'],
                        correctIndex: 2,
                        explanation:
                            '等差数列的通项公式为a_n = a_1 + (n-1)d，其中a_1=1，d=3，所以第20项为1 + (20-1)*3 = 1 + 57 = 58。',
                        lifeLesson: '等差数列是数学中最基本的数列类型之一，掌握其规律有助于解决许多实际问题。',
                    },
                    {
                        content: '等比数列2, 4, 8, 16, ...的公比是多少？',
                        options: ['1', '2', '3', '4'],
                        correctIndex: 1,
                        explanation:
                            '等比数列中，后一项与前一项的比值称为公比。在这个数列中，4/2=2，8/4=2，16/8=2，所以公比是2。',
                        lifeLesson:
                            '等比数列在增长问题中有着广泛的应用，理解其增长模式对分析许多自然和社会现象很有帮助。',
                    },
                    {
                        content: '以下哪个数列是质数数列？',
                        options: ['1, 2, 3, 5, 7', '2, 3, 5, 7, 11', '3, 5, 7, 9, 11', '2, 4, 6, 8, 10'],
                        correctIndex: 1,
                        explanation:
                            '质数是指大于1的自然数，除了1和它本身外，不能被其他自然数整除的数。选项B中的2, 3, 5, 7, 11都是质数，而选项A中的1不是质数，选项C中的9不是质数，选项D中的数都是偶数（除了2）。',
                        lifeLesson: '质数是数学中的基础概念，在数论和密码学等领域有着重要的应用。',
                    },
                ],
                successMessage:
                    '恭喜你完成了数列探索者关卡！你已经掌握了数列的基本规律，这将帮助你在数学探索的道路上发现更多数字的奥秘。',
            },
            {
                title: '几何发现者',
                description:
                    '数学不仅仅是数字，几何图形也蕴含着丰富的数学规律。作为一名数学探索家，你需要理解几何图形的基本性质。',
                lifeGoal: '培养几何直观能力，发现空间与形状的数学规律。',
                questions: [
                    {
                        content: '一个三角形的三个内角之和是多少度？',
                        options: ['90°', '180°', '270°', '360°'],
                        correctIndex: 1,
                        explanation:
                            '在欧几里得几何中，任意三角形的三个内角之和恒等于180度，这是三角形的基本性质之一。',
                        lifeLesson: '几何定理是人类对空间规律的总结，它们帮助我们理解和描述我们周围的世界。',
                    },
                    {
                        content: '正方形的周长为20厘米，它的面积是多少平方厘米？',
                        options: ['20', '25', '40', '50'],
                        correctIndex: 1,
                        explanation:
                            '正方形的周长=4×边长，所以边长=20÷4=5厘米。正方形的面积=边长×边长=5×5=25平方厘米。',
                        lifeLesson: '掌握基本几何图形的周长和面积公式，是解决几何问题的基础。',
                    },
                    {
                        content: '圆的半径为5厘米，它的面积是多少平方厘米？（π取3.14）',
                        options: ['15.7', '31.4', '78.5', '157'],
                        correctIndex: 2,
                        explanation: '圆的面积公式为S=πr²，其中r为半径。所以面积=3.14×5²=3.14×25=78.5平方厘米。',
                        lifeLesson: '圆是自然界中最完美的图形之一，其面积和周长公式在许多领域都有广泛应用。',
                    },
                    {
                        content: '以下哪种图形是正多边形？',
                        options: ['正方形', '长方形', '平行四边形', '梯形'],
                        correctIndex: 0,
                        explanation:
                            '正多边形是指所有边长都相等且所有内角都相等的多边形。正方形的四条边都相等，四个角都是90度，所以是正多边形。而长方形、平行四边形和梯形不满足所有边长相等和所有内角相等的条件。',
                        lifeLesson: '正多边形具有高度的对称性，在艺术、建筑和设计中有着广泛的应用。',
                    },
                    {
                        content: '正方体有多少个面？多少条棱？多少个顶点？',
                        options: [
                            '4个面，6条棱，4个顶点',
                            '6个面，8条棱，8个顶点',
                            '6个面，12条棱，8个顶点',
                            '8个面，12条棱，6个顶点',
                        ],
                        correctIndex: 2,
                        explanation:
                            '正方体是一种正多面体，它有6个面（每个面都是正方形），12条棱（每条棱长度相等），8个顶点（每个顶点连接3条棱）。',
                        lifeLesson: '了解三维几何体的基本结构，有助于培养空间想象能力和解决立体几何问题的能力。',
                    },
                ],
                successMessage:
                    '太棒了！你已经成为了一名出色的几何发现者。掌握几何图形的性质将帮助你在数学探索中发现更多的规律和美感。',
            },
            {
                title: '代数推理师',
                description:
                    '代数是数学的重要分支，作为一名成熟的数学探索家，你需要运用代数思维来解决更复杂的数学问题。',
                lifeGoal: '培养代数思维和逻辑推理能力，是成为优秀数学探索家的关键。',
                questions: [
                    {
                        content: '解方程：2x + 5 = 17',
                        options: ['x = 6', 'x = 8', 'x = 11', 'x = 12'],
                        correctIndex: 0,
                        explanation:
                            '解方程2x + 5 = 17，首先将5移到等号右边得到2x = 17 - 5 = 12，然后两边同时除以2，得到x = 6。',
                        lifeLesson:
                            '代数方程是解决实际问题的有力工具，通过建立方程，我们可以将复杂问题转化为可求解的数学形式。',
                    },
                    {
                        content: '在统计学中，一组数据的平均数、中位数和众数，哪个是出现次数最多的数值？',
                        options: ['平均数', '中位数', '众数', '以上都不是'],
                        correctIndex: 2,
                        explanation:
                            '众数是一组数据中出现次数最多的数值。平均数是所有数据的总和除以数据个数，中位数是将数据按大小顺序排列后位于中间位置的数值。',
                        lifeLesson:
                            '统计学是认识和理解数据的科学，掌握基本的统计概念有助于我们从数据中提取有价值的信息。',
                    },
                    {
                        content: '以下哪个表达式与2x + 3y + 4x - y等价？',
                        options: ['6x + 2y', '5x + 3y', '6x + 4y', '2x + 4y'],
                        correctIndex: 0,
                        explanation: '将同类项合并，2x + 4x = 6x，3y - y = 2y，所以等价于6x + 2y。',
                        lifeLesson: '合并同类项是代数运算的基本技能，它可以帮助我们简化复杂的数学表达式。',
                    },
                    {
                        content: '如果a = 3，b = 4，那么a² + b²等于多少？',
                        options: ['12', '14', '25', '49'],
                        correctIndex: 2,
                        explanation: 'a² = 3² = 9，b² = 4² = 16，所以a² + b² = 9 + 16 = 25。',
                        lifeLesson: '平方和在几何和物理中有着广泛的应用，例如勾股定理就是一种特殊的平方和关系。',
                    },
                    {
                        content: '不等式2x - 3 > 5的解集是什么？',
                        options: ['x > 1', 'x > 4', 'x < 1', 'x < 4'],
                        correctIndex: 1,
                        explanation:
                            '解不等式2x - 3 > 5，首先将-3移到右边得到2x > 5 + 3 = 8，然后两边同时除以2，得到x > 4。',
                        lifeLesson: '不等式在表示范围和限制条件时非常有用，掌握不等式的解法对于解决实际问题很重要。',
                    },
                ],
                successMessage:
                    '恭喜你成为了一名合格的代数推理师！你已经掌握了代数的基本概念和方法，这将帮助你解决更复杂的数学问题。',
            },
            {
                title: '概率统计学家',
                description:
                    '概率和统计是数学中与现实世界联系最紧密的分支之一。作为一名数学探索家，你需要理解随机现象和数据背后的规律。',
                lifeGoal: '培养数据分析能力和概率思维，是理解不确定性世界的关键。',
                questions: [
                    {
                        content: '抛一枚均匀的硬币，正面朝上的概率是多少？',
                        options: ['0', '1/4', '1/2', '1'],
                        correctIndex: 2,
                        explanation:
                            '抛一枚均匀的硬币，有两种可能的结果：正面朝上和反面朝上，且每种结果出现的可能性相等，所以正面朝上的概率是1/2。',
                        lifeLesson:
                            '概率是衡量随机事件发生可能性大小的量，掌握概率的基本概念有助于我们理性地分析和决策。',
                    },
                    {
                        content: '从一副标准的52张扑克牌中随机抽取一张，抽到黑桃的概率是多少？',
                        options: ['1/52', '1/13', '1/4', '1/2'],
                        correctIndex: 2,
                        explanation:
                            '一副标准的扑克牌有4种花色，每种花色有13张牌，所以黑桃有13张。抽到黑桃的概率是13/52 = 1/4。',
                        lifeLesson: '古典概型是概率计算的基础，它适用于所有可能结果有限且等可能的情况。',
                    },
                    {
                        content: '一组数据：5, 7, 8, 9, 10，它们的中位数是多少？',
                        options: ['7', '8', '9', '10'],
                        correctIndex: 1,
                        explanation:
                            '中位数是将数据按大小顺序排列后位于中间位置的数值。这组数据已经按顺序排列，中间的数是8，所以中位数是8。',
                        lifeLesson: '中位数是一种位置平均数，它不受极端值的影响，在描述数据集中趋势时很有用。',
                    },
                    {
                        content: '以下哪种统计量可以反映一组数据的离散程度？',
                        options: ['平均数', '中位数', '众数', '标准差'],
                        correctIndex: 3,
                        explanation:
                            '标准差是衡量数据离散程度的重要统计量，它反映了数据相对于平均数的分散程度。标准差越大，数据的离散程度越大；标准差越小，数据的离散程度越小。',
                        lifeLesson: '了解数据的离散程度，有助于我们更全面地理解数据的分布特征。',
                    },
                    {
                        content: '在概率中，"不可能事件"的概率是多少？"必然事件"的概率是多少？',
                        options: ['0和1', '1和0', '0和0', '1和1'],
                        correctIndex: 0,
                        explanation:
                            '不可能事件是指一定不会发生的事件，其概率为0；必然事件是指一定会发生的事件，其概率为1。',
                        lifeLesson: '概率的取值范围是从0到1，0表示不可能发生，1表示必然发生。',
                    },
                ],
                successMessage:
                    '恭喜你成为了一名出色的概率统计学家！你已经掌握了概率和统计的基本概念和方法，这将帮助你更好地理解和分析现实世界中的随机现象和数据。',
            },
            {
                title: '应用数学家',
                description:
                    '数学不仅是抽象的科学，也是解决实际问题的有力工具。作为一名顶级的数学探索家，你需要将数学知识应用到实际问题中。',
                lifeGoal: '将数学理论与实际应用相结合，用数学思维解决现实问题。',
                questions: [
                    {
                        content: '小明从家到学校的距离是2公里，他步行的速度是每分钟80米，他需要多少分钟才能到达学校？',
                        options: ['15', '20', '25', '30'],
                        correctIndex: 2,
                        explanation: '首先将距离单位统一，2公里=2000米。时间=距离÷速度=2000÷80=25分钟。',
                        lifeLesson: '数学在解决日常生活中的问题时非常有用，掌握基本的数学运算和单位换算技能很重要。',
                    },
                    {
                        content: '一家商店将一件商品的价格从100元提高到120元，提价的百分比是多少？',
                        options: ['10%', '15%', '20%', '25%'],
                        correctIndex: 2,
                        explanation:
                            '提价的金额是120-100=20元。提价的百分比=（提价金额÷原价）×100%=（20÷100）×100%=20%。',
                        lifeLesson:
                            '百分比计算在商业和经济活动中有着广泛的应用，掌握百分比的计算方法有助于我们理解各种经济现象。',
                    },
                    {
                        content:
                            '一个圆柱形水桶的底面半径是30厘米，高是50厘米，它的容积是多少升？（π取3.14，1升=1000立方厘米）',
                        options: ['141.3', '471', '1413', '4710'],
                        correctIndex: 0,
                        explanation:
                            '圆柱的体积公式为V=πr²h，所以水桶的容积=3.14×30²×50=3.14×900×50=141300立方厘米=141.3升。',
                        lifeLesson: '几何知识在计算容器容积、物体体积等实际问题中有着重要的应用。',
                    },
                    {
                        content: '某公司去年的利润是100万元，今年的利润比去年增长了20%，今年的利润是多少万元？',
                        options: ['80', '100', '120', '140'],
                        correctIndex: 2,
                        explanation: '今年的利润=去年的利润×（1+增长率）=100×（1+20%）=100×1.2=120万元。',
                        lifeLesson: '增长率问题在经济分析、人口预测等领域有着广泛的应用，理解增长率的计算方法很重要。',
                    },
                    {
                        content:
                            '在比例尺为1:100000的地图上，量得两地之间的距离是5厘米，那么两地之间的实际距离是多少公里？',
                        options: ['0.5', '5', '50', '500'],
                        correctIndex: 1,
                        explanation:
                            '比例尺1:100000表示地图上的1厘米代表实际距离的100000厘米。所以实际距离=5×100000=500000厘米=5公里。',
                        lifeLesson:
                            '比例尺在地图、工程图纸等领域有着广泛的应用，掌握比例尺的计算方法有助于我们准确理解和使用各种图纸。',
                    },
                ],
                successMessage:
                    '恭喜你成为了一名卓越的应用数学家！你已经成功地将数学知识应用到了各种实际问题中，展现了数学的实用性和魅力。数学是打开科学之门的钥匙，继续你的数学探索之旅吧！',
            },
        ],
        achievements: {
            level1: {
                name: '数列探索者',
                description: '成功完成了数列探索者关卡，掌握了数列的基本规律。',
                icon: '🔢',
            },
            level2: {
                name: '几何发现者',
                description: '掌握了几何图形的基本性质，成为了一名出色的几何发现者。',
                icon: '📐',
            },
            final: {
                name: '数学探索大师',
                description: '成功完成了所有数学问题的挑战，成为了一名真正的数学探索大师！',
                icon: '⭐',
            },
        },
    },
};

// 更新所有角色的进度显示
function updateAllCharacterProgress() {
    // 更新四个角色的进度
    updateCharacterProgress('cyber');
    updateCharacterProgress('heritage');
    updateCharacterProgress('space');
    updateCharacterProgress('math');
}

// 更新单个角色的进度显示
function updateCharacterProgress(characterId) {
    const completedLevels = getCompletedLevels(characterId);
    const totalLevels = characterTotalLevels[characterId];
    const progressPercentage = (completedLevels / totalLevels) * 100;

    // 更新进度条宽度
    const progressFill = elements[`${characterId}ProgressFill`];
    const progressInfo = elements[`${characterId}ProgressInfo`];

    if (progressFill && progressInfo) {
        progressFill.style.width = `${progressPercentage}%`;
        progressInfo.textContent = `${completedLevels}/${totalLevels}`;
    }
}

// 获取指定角色已完成的关卡数
function getCompletedLevels(characterId) {
    // 添加错误检查，确保characters对象存在
    if (typeof characters === 'undefined') {
        console.error('characters对象未定义');
        return 0;
    }

    if (typeof characterId !== 'string') {
        console.error('characterId必须是字符串类型');
        return 0;
    }

    // 从本地存储加载成就信息
    let achievements = [];
    try {
        achievements = JSON.parse(localStorage.getItem('achievements') || '[]');
    } catch (error) {
        console.error('加载成就失败:', error);
    }

    // 从analytics中获取关卡完成信息
    const completedLevel = appState?.analytics?.levelCompletions?.[characterId] || 0;

    // 获取角色的成就定义，增加额外的错误检查
    const characterAchievements = (characters && characters[characterId] && characters[characterId].achievements) || {};

    // 计算已完成的关卡数
    let count = 0;

    // 检查characterTotalLevels是否存在
    if (typeof characterTotalLevels !== 'undefined' && characterTotalLevels[characterId]) {
        // 检查每个关卡成就是否已完成
        for (let i = 1; i <= characterTotalLevels[characterId]; i++) {
            const levelKey = `level${i}`;
            const levelAchievement = characterAchievements[levelKey];

            if (levelAchievement && achievements.includes(levelAchievement.name)) {
                count++;
            }
        }
    } else {
        console.warn(`未找到角色${characterId}的总关卡数定义`);
    }

    // 返回较大的值，确保进度条不会回退
    return Math.max(count, completedLevel);
}

// 音效管理器
const soundEffects = {
    // 音频上下文（懒加载）
    _audioContext: null,

    // 获取或创建音频上下文
    _getAudioContext() {
        if (!this._audioContext) {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            try {
                this._audioContext = new AudioContext();
            } catch (e) {
                console.error('创建AudioContext失败:', e);
            }
        }

        // 确保音频上下文处于运行状态
        if (this._audioContext && this._audioContext.state === 'suspended') {
            this._audioContext.resume().catch((e) => {
                console.error('恢复AudioContext失败:', e);
            });
        }

        return this._audioContext;
    },

    // 播放角色选择音效
    playCharacterSelect(characterId) {
        // 使用Web Audio API播放简单的声音
        this._playSimpleSound(440, 0.1); // 440Hz，持续0.1秒
        console.log(`播放角色选择音效: ${characterId}`);
    },

    // 播放故事进度音效
    playStoryProgress() {
        // 使用Web Audio API播放简单的声音序列
        this._playSimpleSound(330, 0.1); // 330Hz
        setTimeout(() => this._playSimpleSound(440, 0.1), 100); // 延迟100ms播放440Hz
        console.log('播放故事进度音效');
    },

    // 播放成功音效
    playSuccess() {
        // 使用Web Audio API播放简单的成功音效
        this._playSimpleSound(523.25, 0.1); // C5
        setTimeout(() => this._playSimpleSound(659.25, 0.1), 100); // E5
        setTimeout(() => this._playSimpleSound(783.99, 0.2), 200); // G5
        console.log('播放成功音效');
    },

    // 播放反馈语音 - 使用Web Audio API修复版 + 语音播报
    playFeedbackVoice(style) {
        console.log(`尝试播放${style}风格的语音反馈（Web Audio API修复版）`);

        try {
            const audioContext = this._getAudioContext();
            if (!audioContext) {
                console.error('AudioContext不可用，无法播放声音');
                return;
            }

            // 根据风格选择不同的音高
            let frequency = 440; // 默认A4
            switch (style) {
                case 'happy':
                    frequency = 523.25; // C5
                    break;
                case 'encouraging':
                    frequency = 493.88; // B4
                    break;
                case 'surprised':
                    frequency = 587.33; // D5
                    break;
                default:
                    frequency = 440; // A4
            }

            // 播放反馈声音
            this._playSimpleSound(frequency, 0.5);
            console.log(`成功播放${style}风格的语音反馈（Web Audio API修复版）`);
            
            // 添加语音播报鼓励语
            this._speakEncouragement(style);
        } catch (error) {
            console.error('播放语音过程中发生异常:', error);
        }
    },
    
    // 播放答错反馈
    playWrongFeedback() {
        try {
            // 播放错误音效（较低频率）
            this._playSimpleSound(200, 0.3);
            console.log('播放答错音效');
            
            // 使用语音播报统一文案
            this._speakWrongMessage();
        } catch (error) {
            console.error('播放答错语音过程中发生异常:', error);
        }
    },
    
    // 使用Web Speech API播报答错提示
    _speakWrongMessage() {
        // 检查浏览器是否支持语音合成
        if (!('speechSynthesis' in window)) {
            console.warn('浏览器不支持语音合成功能');
            return;
        }
        
        try {
            // 统一的答错文案(四川方言)
            const message = '呕吼~死翘翘咯';
            
            // 创建语音合成实例
            const utterance = new SpeechSynthesisUtterance(message);
            
            // 设置语音参数（使用较温和的参数）
            utterance.lang = 'zh-CN';
            utterance.rate = 1.0;  // 正常语速
            utterance.pitch = 1.1; // 略高音调
            utterance.volume = 0.9; // 略低音量
            
            // 尝试选择合适的语音
            const voices = window.speechSynthesis.getVoices();
            const preferredVoice = voices.find(voice => 
                voice.lang.includes('zh') && 
                (voice.name.includes('Xiaoyi') || voice.name.includes('Xiaoxiao'))
            );
            
            if (preferredVoice) {
                utterance.voice = preferredVoice;
                console.log(`选择语音: ${preferredVoice.name}`);
            }
            
            // 播放语音
            window.speechSynthesis.speak(utterance);
            console.log('播放答错语音提示: ' + message);
        } catch (error) {
            console.error('语音播报答错提示失败:', error);
        }
    },
    
    // 使用Web Speech API播报鼓励语
    _speakEncouragement(style) {
        // 检查浏览器是否支持语音合成
        if (!('speechSynthesis' in window)) {
            console.warn('浏览器不支持语音合成功能');
            return;
        }
        
        // 根据风格选择不同的鼓励语(西安方言)
        const encouragements = {
            '总裁': [
                '嘹咋咧！思路清楚得很，逻辑严实得很。',
                '额滴神，这个问题处理得美得很。',
                '太嘹咋咧，你已经把里头的门道摸透咧。'
            ],
            '二次元': [
                '我滴个乖乖，你太厉害咧！',
                '美得太太，你肯定是学霸吧！',
                '嘹得太太，这个解法神得很！'
            ],
            '萌妹': [
                '哎呀咧，你太嘹咋咧！',
                '厉害得太太，好崇拜你咧！',
                '我滴个乖乖，全对咧！'
            ],
            '学者': [
                '嘹得很，你的解答展现了清晰的逻辑思维。',
                '对咧，你已经把这个规律摸透咧。',
                '精彩得太太，你已经触及到问题的本质咧。'
            ],
            '武侠': [
                '好嘞！这一招使得妙得很！',
                '额滴神！解法干脆利落！',
                '美得太太！此等解题思路精妙绝伦！'
            ],
            'default': [
                '回答对咧！你太嘹咋咧！',
                '美得太太！接着再来！',
                '答对咧！你脑子活泛得很！'
            ]
        };
        
        // 获取对应风格的鼓励语数组，如果没有则使用默认
        const messages = encouragements[style] || encouragements['default'];
        const message = messages[Math.floor(Math.random() * messages.length)];
        
        try {
            // 创建语音合成实例
            const utterance = new SpeechSynthesisUtterance(message);
            
            // 获取可用的语音列表
            const voices = window.speechSynthesis.getVoices();
            
            // 根据不同风格设置不同的语音参数和选择合适的音色
            utterance.lang = 'zh-CN'; // 中文
            
            // 优先选择质量更好的中文语音
            let selectedVoice = null;
            
            // 根据风格选择合适的音色（优先女声或男声）
            switch(style) {
                case '总裁':
                    // 选择男声，优先 Microsoft Yunyang 或其他男声
                    selectedVoice = voices.find(v => 
                        v.lang.includes('zh') && 
                        (v.name.includes('Yunyang') || v.name.includes('Male') || v.name.includes('男'))
                    );
                    utterance.rate = 0.85; // 更慢更稳重的语速
                    utterance.pitch = 0.80; // 更低沉有力的音调
                    utterance.volume = 0.95; // 略微降低音量增加沉稳感
                    break;
                case '二次元':
                    // 选择女声，优先 Microsoft Xiaoxiao 或其他活泼女声
                    selectedVoice = voices.find(v => 
                        v.lang.includes('zh') && 
                        (v.name.includes('Xiaoxiao') || v.name.includes('Female') || v.name.includes('女'))
                    );
                    utterance.rate = 1.28; // 更快更活泼的语速
                    utterance.pitch = 1.60; // 更高更可爱的音调
                    utterance.volume = 1.0; // 保持饱满音量
                    break;
                case '萌妹':
                    // 选择女声，优先 Microsoft Xiaoyi 或甜美女声
                    selectedVoice = voices.find(v => 
                        v.lang.includes('zh') && 
                        (v.name.includes('Xiaoyi') || v.name.includes('Xiaoxiao') || v.name.includes('Female') || v.name.includes('女'))
                    );
                    utterance.rate = 1.08; // 略快增加活泼感
                    utterance.pitch = 1.70; // 非常高的音调突出甜美
                    utterance.volume = 0.90; // 降低音量增加柔和感
                    break;
                case '学者':
                    // 选择标准男声或女声
                    selectedVoice = voices.find(v => 
                        v.lang.includes('zh') && 
                        (v.name.includes('Yunxi') || v.name.includes('Zhiyu'))
                    );
                    utterance.rate = 0.80; // 更慢更沉稳的语速
                    utterance.pitch = 0.92; // 略低增加权威感
                    utterance.volume = 0.88; // 降低音量增加温和感
                    break;
                case '武侠':
                    // 选择男声，显得豪迈
                    selectedVoice = voices.find(v => 
                        v.lang.includes('zh') && 
                        (v.name.includes('Yunyang') || v.name.includes('Male') || v.name.includes('男'))
                    );
                    utterance.rate = 1.15; // 更快更有力的语速
                    utterance.pitch = 0.85; // 更低增加豪迈感
                    utterance.volume = 1.0; // 保持饱满音量
                    break;
                default:
                    selectedVoice = voices.find(v => v.lang.includes('zh'));
                    utterance.rate = 1.0;
                    utterance.pitch = 1.2;
                    utterance.volume = 1.0;
            }
            
            // 如果没有找到特定音色，使用任何可用的中文语音
            if (!selectedVoice) {
                selectedVoice = voices.find(v => v.lang.includes('zh') || v.lang.includes('CN'));
            }
            
            // 设置选中的音色
            if (selectedVoice) {
                utterance.voice = selectedVoice;
                console.log(`使用语音: ${selectedVoice.name}`);
            }
            
            // 播放语音
            window.speechSynthesis.speak(utterance);
            console.log(`语音播报[${style}风格]: ${message} (语速:${utterance.rate}, 音调:${utterance.pitch})`);
        } catch (error) {
            console.error('语音播报失败:', error);
        }
    },

    // 通用的Web Audio API声音播放函数
    _playSimpleSound(frequency, duration) {
        try {
            const audioContext = this._getAudioContext();
            if (!audioContext) return;

            // 创建振荡器和增益节点
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            // 连接节点
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            // 设置参数
            oscillator.type = 'sine'; // 正弦波
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);

            // 设置音量（0.5表示中等音量）
            gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);

            // 添加淡出效果避免爆音
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

            // 播放声音
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        } catch (e) {
            console.error('播放声音失败:', e);
        }
    },
};

// DOM元素引用
const elements = {
    // 主步骤容器
    characterSelection: document.getElementById('character-selection'),
    storyExperience: document.getElementById('story-experience'),
    battleMode: document.getElementById('battle-mode'),
    achievementModal: document.getElementById('achievement-modal'),

    // 角色选择相关
    characterCards: document.querySelectorAll('.character-card'),

    // 进度条相关元素
    cyberProgressFill: document.querySelector('.cyber-progress .progress-fill'),
    cyberProgressInfo: document.querySelector('.cyber-progress .progress-info'),
    heritageProgressFill: document.querySelector('.heritage-progress .progress-fill'),
    heritageProgressInfo: document.querySelector('.heritage-progress .progress-info'),
    spaceProgressFill: document.querySelector('.space-progress .progress-fill'),
    spaceProgressInfo: document.querySelector('.space-progress .progress-info'),
    mathProgressFill: document.querySelector('.math-progress .progress-fill'),
    mathProgressInfo: document.querySelector('.math-progress .progress-info'),

    // 故事体验相关
    storyTitle: document.getElementById('story-title'),
    storyNarration: document.getElementById('story-narration'),
    storyChoices: document.getElementById('story-choices'),
    nextStoryBtn: document.getElementById('next-story'),
    backToSelectionBtn: document.getElementById('back-to-selection'),

    // 战斗模式相关
    battleTitle: document.getElementById('battle-title'),
    currentQuestion: document.getElementById('current-question'),
    totalQuestions: document.getElementById('total-questions'),
    questionContainer: document.getElementById('question-container'),
    optionsContainer: document.getElementById('options-container'),
    feedback: document.getElementById('feedback'),
    nextQuestionBtn: document.getElementById('next-question'),
    backToStoryBtn: document.getElementById('back-to-story'),

    // 成就弹窗相关
    achievementTitleText: document.getElementById('achievement-title-text'),
    achievementDescription: document.getElementById('achievement-description'),
    achievementIcon: document.getElementById('achievement-icon'),
    restartJourneyBtn: document.getElementById('restart-journey'),

    // 关卡信息相关
    levelTitle: document.getElementById('level-title'),
    levelDescription: document.getElementById('level-description'),
    levelGoal: document.getElementById('level-goal'),

    // 继续按钮
    continueBtn: document.getElementById('continue-btn'),
};

// 角色总关卡数定义
const characterTotalLevels = {
    cyber: characters.cyber.levels.length,
    heritage: characters.heritage.levels.length,
    space: characters.space.levels.length,
    math: characters.math.levels.length,
};

// 初始化应用
function initApp() {
    // 预加载语音列表（用于语音播报功能）
    if ('speechSynthesis' in window) {
        // 触发语音列表加载
        window.speechSynthesis.getVoices();
        // 监听语音列表变化事件
        window.speechSynthesis.onvoiceschanged = () => {
            console.log('语音列表已加载，可用语音数量:', window.speechSynthesis.getVoices().length);
        };
    }

    // 加载本地存储的数据
    loadFromLocalStorage();

    // 确保所有需要的状态字段都已初始化
    if (!appState.levelAttempts) {
        appState.levelAttempts = {
            level1: 0,
            level2: 0,
            level3: 0,
        };
    }

    if (!appState.retryQuestions) {
        appState.retryQuestions = [];
    }

    if (!appState.analytics) {
        appState.analytics = {
            totalPlays: 0,
            characterSelection: {
                cyber: 0,
                heritage: 0,
                space: 0,
                math: 0,
            },
            storyConversion: 0,
            battleCompletion: 0,
            levelCompletions: {},
            purchasePrompts: 0,
        };
    }

    // 绑定事件监听器
    bindEventListeners();

    // 更新UI显示
    updateUI();

    // 更新所有角色的进度显示
    updateAllCharacterProgress();

    // 延迟启动粒子动画，确保DOM完全加载
    setTimeout(() => {
        if (typeof startParticleAnimation === 'function') {
            startParticleAnimation();
        } else {
            console.log('粒子动画功能未加载，尝试稍后重新加载...');
        }
    }, 500);
}

// 绑定事件监听器
function bindEventListeners() {
    // 角色选择卡片点击事件
    elements.characterCards.forEach((card) => {
        card.addEventListener('click', () => {
            const characterId = card.getAttribute('data-character');
            selectCharacter(characterId);
        });
    });

    // 返回按钮事件
    elements.backToSelectionBtn.addEventListener('click', goBackToSelection);
    elements.backToStoryBtn.addEventListener('click', goBackToStory);

    // 继续按钮事件
    elements.nextStoryBtn.addEventListener('click', nextStory);
    elements.nextQuestionBtn.addEventListener('click', nextQuestion);

    // 重启旅程按钮事件
    elements.restartJourneyBtn.addEventListener('click', restartJourney);
}

// 选择角色
function selectCharacter(characterId) {
    appState.selectedCharacter = characterId;
    appState.currentStoryIndex = 0;
    appState.currentStep = 'story';

    // 播放角色选择音效
    soundEffects.playCharacterSelect(characterId);

    // 更新埋点数据
    appState.analytics.characterSelection[characterId]++;
    appState.analytics.totalPlays++;

    // 保存到本地存储
    saveToLocalStorage();

    // 更新UI
    updateUI();
}

// 下一个故事段落
function nextStory() {
    if (!appState.selectedCharacter) return;

    const character = characters[appState.selectedCharacter];
    appState.currentStoryIndex++;

    // 播放故事进度音效
    soundEffects.playStoryProgress();

    // 检查是否已经完成所有故事段落
    if (appState.currentStoryIndex >= character.story.length) {
        // 检查是否需要进入战斗模式
        if (character.story[character.story.length - 1].startBattle) {
            startBattle();
        }
        return;
    }

    // 更新UI
    updateUI();
}

// 开始战斗（答题）模式
function startBattle() {
    appState.currentStep = 'battle';
    appState.currentLevel = 1;
    appState.currentQuestionIndex = 0;
    appState.selectedOptions = [];
    appState.score = 0;
    appState.lives = 3;
    appState.retryQuestions = [];
    appState.levelAttempts = {
        level1: 0,
        level2: 0,
        level3: 0,
    };

    // 更新埋点数据
    appState.analytics.storyConversion++;

    // 保存到本地存储
    saveToLocalStorage();

    // 更新UI
    updateUI();
}

// 选择答案
function selectAnswer(index) {
    if (!appState.selectedCharacter) return;

    const currentCharacter = characters[appState.selectedCharacter];
    const currentLevel = currentCharacter.levels[appState.currentLevel - 1];

    // 判断是显示错题还是正常题目
    let question,
        isRetryQuestion = false;
    if (appState.retryQuestions.length > 0) {
        question = appState.retryQuestions[0];
        isRetryQuestion = true;
    } else {
        question = currentLevel.questions[appState.currentQuestionIndex];
    }

    const isCorrect = index === question.correctIndex;

    if (isCorrect) {
        appState.score++;

        // 如果是错题重练，从错题列表中移除
        if (isRetryQuestion) {
            appState.retryQuestions.shift();
        }
    } else {
        appState.lives--;

        // 如果回答错误，将题目添加到错题列表末尾
        if (!isRetryQuestion) {
            appState.retryQuestions.push(question);
        }
    }

    // 显示反馈
    showFeedback(isCorrect, question.explanation);

    // 禁用所有选项
    const options = elements.optionsContainer.querySelectorAll('.option');
    options.forEach((option, i) => {
        option.disabled = true;
        if (i === index) {
            option.classList.add(isCorrect ? 'correct' : 'incorrect');
        } else if (i === question.correctIndex) {
            option.classList.add('correct');
        }
    });

    // 显示下一题按钮
    elements.nextQuestionBtn.classList.remove('hidden');

    // 保存到本地存储
    saveToLocalStorage();
}

// 生成部分解析内容（用于第四个及以后的错题）
function generatePartialExplanation(explanation) {
    // 部分解析包含基本的解题思路和被马赛克遮挡的完整解析框架
    let partialContent = '';

    // 计算解析完成度比例（部分解析显示约30%内容）
    const completionPercentage = 30;

    partialContent += `
        <div class="explanation-section">
            <h4 class="explanation-title">🔍 解题思路</h4>
            <div class="solution-steps">
                <div class="solution-step">
                    <span class="step-icon">△</span>
                    <span class="step-content">这道题目的关键在于理解${explanation.substring(0, 30)}...</span>
                </div>
            </div>
        </div>
        
        <!-- 马赛克遮挡区域 - 优化为只显示一个带有动态效果的提示 -->
        <div class="explanation-section masked-section">
            <div class="masked-content">
                <!-- 这里是被马赛克遮挡的完整解析内容 -->
            </div>
            <div class="mask-overlay animated-mask">
                <div class="mask-pattern"></div>
                <div class="mask-text pulse-animation">
                    <span class="lock-icon">🔒</span>
                    <span>分享解锁剩余 ${100 - completionPercentage}% 内容</span>
                </div>
            </div>
        </div>`;

    // 添加动态效果样式
    if (!document.getElementById('mask-animation-style')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'mask-animation-style';
        styleElement.textContent = `
            @keyframes maskPulse {
                0% { opacity: 0.8; transform: scale(1); }
                50% { opacity: 1; transform: scale(1.02); }
                100% { opacity: 0.8; transform: scale(1); }
            }
            .animated-mask .mask-text.pulse-animation {
                animation: maskPulse 2s infinite;
            }
            .masked-section {
                position: relative;
                margin-bottom: 20px;
                padding: 20px;
                background-color: #f8f9fa;
                border-radius: 8px;
                overflow: hidden;
            }
            .mask-overlay {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                display: flex;
                justify-content: center;
                align-items: center;
                background-color: rgba(0, 0, 0, 0.6);
                z-index: 1;
            }
            .mask-pattern {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0MCIgaGVpZ2h0PSI0MCI+PGcgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjZmZmIiBzdHJva2Utd2lkdGg9IjEiPjxwYXRoIGQ9Ik0wIDBoMjB2MjBIMHoiLz48cGF0aCBkPSJNMjAgMjBoMjB2MjBIMjB6Ii8+PC9nPjwvc3ZnPg==');
                opacity: 0.2;
            }
            .mask-text {
                color: white;
                font-weight: bold;
                text-align: center;
                padding: 15px;
                background-color: rgba(108, 92, 231, 0.9);
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                z-index: 2;
            }
            .lock-icon {
                margin-right: 8px;
            }
        `;
        document.head.appendChild(styleElement);
    }

    return partialContent;
}

// 生成详细的题目解析
function generateDetailedExplanation(explanation, question) {
    // 默认的详细解析，会根据传入的explanation和question内容进行增强
    let detailedContent = '';

    // 1. 拆解题目考查的知识点
    if (question.knowledgePoint) {
        detailedContent += `
        <div class="explanation-section">
            <h4 class="explanation-title">📚 考查知识点</h4>
            <p>${question.knowledgePoint}</p>
        </div>`;
    } else {
        detailedContent += `
        <div class="explanation-section">
            <h4 class="explanation-title">📚 考查知识点</h4>
            <p>本题主要考查了解题者对相关概念的理解和应用能力。</p>
        </div>`;
    }

    // 2. 分步骤演示解题过程
    let stepByStep = '';
    if (question.solutionSteps && Array.isArray(question.solutionSteps)) {
        stepByStep = question.solutionSteps
            .map((step, index) => {
                const stepIcon = ['△', '→', '★', '✓', '➤'][index % 5];
                return `
            <div class="solution-step">
                <span class="step-icon">${stepIcon}</span>
                <span class="step-content">${step}</span>
            </div>`;
            })
            .join('');
    } else if (explanation) {
        // 如果没有预定义的步骤，尝试从explanation中提取关键步骤
        stepByStep = `
            <div class="solution-step">
                <span class="step-icon">△</span>
                <span class="step-content">首先，我们需要明确题目要求和已知条件。</span>
            </div>
            <div class="solution-step">
                <span class="step-icon">→</span>
                <span class="step-content">${explanation}</span>
            </div>
            <div class="solution-step">
                <span class="step-icon">★</span>
                <span class="step-content">通过以上分析，可以得出正确答案。</span>
            </div>`;
    }

    detailedContent += `
        <div class="explanation-section">
            <h4 class="explanation-title">🔍 解题过程</h4>
            <div class="solution-steps">${stepByStep}</div>
        </div>`;

    // 3. 针对错误选项说明常见误区
    if (question.commonMistakes) {
        detailedContent += `
        <div class="explanation-section">
            <h4 class="explanation-title">⚠️ 常见误区</h4>
            <p>${question.commonMistakes}</p>
        </div>`;
    } else {
        detailedContent += `
        <div class="explanation-section">
            <h4 class="explanation-title">⚠️ 常见误区</h4>
            <p>在解答此类题目时，容易忽略细节或混淆概念。请仔细审题，明确各个条件之间的关系。</p>
        </div>`;
    }

    // 4. 补充同类题型的解题技巧
    if (question.solutionTips) {
        detailedContent += `
        <div class="explanation-section">
            <h4 class="explanation-title">💡 解题技巧</h4>
            <p>${question.solutionTips}</p>
        </div>`;
    } else {
        detailedContent += `
        <div class="explanation-section">
            <h4 class="explanation-title">💡 解题技巧</h4>
            <p>解决这类问题时，可以尝试：1) 仔细分析题目条件；2) 列出已知信息和要求；3) 逐步推导；4) 验证答案的合理性。</p>
        </div>`;
    }

    return detailedContent;
}

// 显示答题反馈
function showFeedback(isCorrect, explanation) {
    // 如果回答正确，播放成功音效
    if (isCorrect) {
        soundEffects.playSuccess();
    }
    // 获取当前问题以获取人生启示
    let question;
    const character = characters[appState.selectedCharacter];
    const currentLevel = character.levels[appState.currentLevel - 1];

    // 判断是显示错题还是正常题目
    if (appState.retryQuestions.length > 0) {
        question = appState.retryQuestions[0];
    } else {
        question = currentLevel.questions[appState.currentQuestionIndex];
    }

    // 多样化人物形象口吻的反馈文案
    const characterStyles = {
        总裁: [
            '很好，这种解题思路很对我的胃口。继续保持，我欣赏你这种逻辑清晰的人。',
            '不错，这个问题处理得很到位。作为我的人，就该有这种敏锐的洞察力。',
            '很好，完全正确！看来你已经掌握了其中的精髓。',
            '回答得漂亮！我从不夸人，但这次我要给你点个赞。',
            '非常好，思路清晰，逻辑严密。这才是我认可的水平。',
        ],
        二次元: [
            '哇塞～你超厉害的耶！这个问题都能答对，简直是学霸属性全开呢！✨',
            '太棒啦！你一定是隐藏的数学大佬吧？膜拜ing～',
            '好厉害！这个解法太神了，感觉你在发光呢！',
            '正确！你的智商简直突破天际啦，我要给你打call！',
            '耶！答对了！你真是个天才，爱了爱了～',
        ],
        萌妹: [
            '哇～你好棒哦！这个题目人家想了好久都没头绪的说～',
            '太厉害了啦～怎么可以这么聪明呢？好崇拜你哦～',
            '哇塞！完全正确呢～你是不是偷偷复习了呀？',
            '太棒了啦！这个解法超厉害的，人家都没想到呢～',
            '对了对了！你好聪明哦，我都要给你点一百个赞～',
        ],
        学者: [
            '很好，你的解答展现了清晰的逻辑思维和扎实的基础知识。',
            '正确，这个问题的关键就在于你所掌握的这个规律。',
            '非常精彩，你已经触及到了这个问题的本质。',
            '恭喜你，你的思考过程完全符合科学的方法论。',
            '很好，你的解答验证了我们之前讨论的理论的正确性。',
        ],
        武侠: [
            '好！这一招使得妙！看来你已深得此道精髓！',
            '不错！解法干脆利落，颇有大家风范！',
            '妙哉！此等解题思路，当真如同剑走偏锋，精妙绝伦！',
            '好功夫！这道题的难点被你一击中的，佩服佩服！',
            '痛快！你的解法如同行云流水，毫无凝滞，真乃高手！',
        ],
    };

    let feedbackHTML = '';
    if (isCorrect) {
        // 随机选择一种人物风格
        const styles = Object.keys(characterStyles);
        const randomStyle = styles[Math.floor(Math.random() * styles.length)];
        const styleMessages = characterStyles[randomStyle];
        const randomMessage = styleMessages[Math.floor(Math.random() * styleMessages.length)];

        // 构建反馈HTML，不显示口吻标签
        feedbackHTML = `
            <div class="feedback-style">${randomMessage}</div>
        `;

        // 播放对应口吻的语音反馈
        soundEffects.playFeedbackVoice(randomStyle);

        // 如果有人生启示，以独立字体颜色突出显示
        if (question.lifeLesson) {
            feedbackHTML += `
                <div class="feedback-lesson">
                    <span class="lesson-icon">💡</span>
                    <span class="lesson-text">${question.lifeLesson}</span>
                </div>
            `;
        }
    } else {
        // 播放答错语音提示
        soundEffects.playWrongFeedback();
        
        // 增加当前关卡的错题计数（记录不同的题目）
        const levelKey = `level${appState.currentLevel}`;
        // 初始化答错题目集合
        if (!appState.wrongQuestionIds) {
            appState.wrongQuestionIds = {};
        }
        if (!appState.wrongQuestionIds[levelKey]) {
            appState.wrongQuestionIds[levelKey] = new Set();
        }

        // 记录答错的题目ID（使用题目内容的哈希值作为ID）
        const questionId = question.content.hashCode();
        appState.wrongQuestionIds[levelKey].add(questionId);

        // 根据答错的不同题目数量决定显示完整解析还是部分解析
        const wrongCount = appState.wrongQuestionIds[levelKey].size;
        if (wrongCount <= 3) {
            // 前三个错题显示完整解析
            const detailedExplanation = generateDetailedExplanation(explanation, question);
            feedbackHTML = `<div class="feedback-wrong">回答错误。</div>
                            <div class="detailed-explanation">${detailedExplanation}</div>`;
        } else {
            // 第四个及以后的错题显示部分解析
            const partialExplanation = generatePartialExplanation(explanation);
            const friendCountToUnlock = 3; // 每邀请3位好友可解锁新功能
            const unlockedFeature = '高级解析库'; // 解锁的新功能

            // 检查是否已经显示过分享提示
            const levelKey = `level${appState.currentLevel}`;
            const sharePromptKey = `${levelKey}_sharePromptShown`;

            // 首次触发时才显示分享提示区域
            if (!appState[sharePromptKey]) {
                feedbackHTML = `<div class="feedback-wrong">回答错误。</div>
                                <div class="detailed-explanation">${partialExplanation}</div>
                                <div class="share-locked-explanation">
                                    <p>🎯 您已查看了本关卡的3个完整解析</p>
                                    <p>💡 分享给好友可解锁此解析的完整内容</p>
                                    <button class="share-button floating-button pulse-animation">分享好友解锁完整版</button>
                                    <div class="reward-info">
                                        <div class="reward-icon">🎁</div>
                                        <div class="reward-text">
                                            <div class="reward-title">额外奖励</div>
                                            <div class="reward-description">每成功邀请${friendCountToUnlock}人，可解锁${unlockedFeature}！</div>
                                        </div>
                                    </div>
                                </div>`;

                // 标记此关卡已经显示过分享提示
                appState[sharePromptKey] = true;
            } else {
                // 后续只显示部分解析，不重复显示分享提示
                feedbackHTML = `<div class="feedback-wrong">回答错误。</div>
                                <div class="detailed-explanation">${partialExplanation}</div>`;
            }
        }
    }

    // 增加当前关卡的尝试次数（仅在回答错误时）
    if (!isCorrect) {
        const levelKey = `level${appState.currentLevel}`;
        appState.levelAttempts[levelKey] = (appState.levelAttempts[levelKey] || 0) + 1;

        // 检查是否需要显示购买引导（恰好答错3次时才触发）
        if (appState.levelAttempts[levelKey] === 3) {
            // 显示购买引导弹窗
            setTimeout(() => {
                showPurchasePrompt();
            }, 1500);
        }
    }

    elements.feedback.innerHTML = feedbackHTML;
    elements.feedback.className = `feedback ${isCorrect ? 'correct' : 'incorrect'}`;
    elements.feedback.classList.remove('hidden');
    elements.feedback.style.display = 'block'; // 明确设置display属性，确保可见

    // 为分享按钮添加点击事件监听
    if (!isCorrect) {
        const shareButton = elements.feedback.querySelector('.share-button');
        if (shareButton) {
            shareButton.addEventListener('click', () => {
                // 打开分享弹窗
                openShareModal();
                
                // 可选:分享成功后自动解锁完整解析
                // 在实际应用中,这里可以在用户完成分享后再调用unlockFullExplanation()
                // 当前为了演示,打开分享弹窗后用户可以选择复制链接或扫码分享
            });
        }
    }
}

// 进入下一题或下一关
function nextQuestion() {
    if (!appState.selectedCharacter) return;

    const character = characters[appState.selectedCharacter];

    // 如果有错题需要重练，继续留在当前关卡
    if (appState.retryQuestions.length > 0) {
        // 移除当前已作答的错题，准备显示下一道错题
        appState.retryQuestions.shift();
        updateBattleUI();
        return;
    }

    const currentLevel = character.levels[appState.currentLevel - 1];

    // 检查是否完成了当前关卡的所有题目
    if (appState.currentQuestionIndex >= currentLevel.questions.length) {
        // 完成当前关卡
        const levelKey = `level${appState.currentLevel}`;

        // 重置关卡尝试次数
        appState.levelAttempts[levelKey] = 0;

        // 显示关卡完成成就（如果有的话）
        const levelAchievement = character.achievements[levelKey];
        if (levelAchievement) {
            showAchievement(levelAchievement);
            return; // 如果显示了成就弹窗，就不再继续下面的逻辑
        }

        // 记录关卡完成情况
        appState.analytics.levelCompletions[appState.selectedCharacter] = appState.currentLevel;
        saveToLocalStorage();

        // 检查是否还有下一关
        const nextLevelIndex = appState.currentLevel;
        if (nextLevelIndex < character.levels.length) {
            // 准备下一关信息
            const nextLevel = character.levels[nextLevelIndex];

            // 显示当前关卡成功信息和下一关卡引导提示
            elements.feedback.innerHTML = `
                <div>${currentLevel.successMessage}</div>
                <div style="margin-top: 15px; font-size: 1.1em;">下一关: ${nextLevel.title}</div>
                <div style="margin-top: 5px; color: var(--accent-color-3);">${nextLevel.description}</div>
            `;
            elements.feedback.style.display = 'block';
            elements.feedback.style.textAlign = 'center';
            elements.feedback.style.padding = '20px';
            elements.feedback.style.backgroundColor = 'rgba(255, 255, 255, 0.95)';
            elements.feedback.style.borderRadius = '10px';
            elements.feedback.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.15)';

            // 检查继续按钮是否存在，防止未定义错误
            if (elements.continueBtn) {
                // 显示继续按钮
                elements.continueBtn.textContent = '继续闯关';
                elements.continueBtn.classList.remove('hidden');

                // 为继续按钮添加点击事件
                elements.continueBtn.onclick = () => {
                    // 进入下一关
                    appState.currentLevel++;
                    appState.currentQuestionIndex = 0;

                    // 隐藏反馈和继续按钮
                    elements.feedback.style.display = 'none';
                    elements.continueBtn.classList.add('hidden');

                    // 更新UI，进入下一关的刷题界面
                    updateBattleUI();
                };
            } else {
                // 如果继续按钮不存在，使用nextQuestionBtn作为替代
                if (elements.nextQuestionBtn) {
                    elements.nextQuestionBtn.textContent = '继续闯关';
                    elements.nextQuestionBtn.classList.remove('hidden');

                    // 临时存储原始点击事件处理程序
                    const originalNextQuestionHandler = elements.nextQuestionBtn.onclick;

                    // 设置临时点击事件处理程序
                    elements.nextQuestionBtn.onclick = () => {
                        // 进入下一关
                        appState.currentLevel++;
                        appState.currentQuestionIndex = 0;

                        // 隐藏反馈
                        elements.feedback.style.display = 'none';

                        // 恢复原始点击事件处理程序
                        elements.nextQuestionBtn.textContent = '下一题';
                        elements.nextQuestionBtn.onclick = originalNextQuestionHandler;

                        // 更新UI，进入下一关的刷题界面
                        updateBattleUI();
                    };
                }
            }
        } else {
            // 完成所有关卡，显示最终成就
            setTimeout(() => {
                showAchievement(character.achievements.final);
            }, 2000);
        }
    } else {
        // 没有完成当前关卡，继续下一题
        appState.currentQuestionIndex++;
        updateBattleUI();
    }
}

// 显示购买引导弹窗
function showPurchasePrompt() {
    // 首先移除可能存在的旧弹窗
    const oldModal = document.getElementById('purchase-modal');
    if (oldModal) {
        oldModal.remove();
    }

    // 创建购买引导弹窗
    const purchaseModal = document.createElement('div');
    purchaseModal.id = 'purchase-modal';
    purchaseModal.style.position = 'fixed';
    purchaseModal.style.top = '0';
    purchaseModal.style.left = '0';
    purchaseModal.style.width = '100%';
    purchaseModal.style.height = '100%';
    purchaseModal.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
    purchaseModal.style.display = 'flex';
    purchaseModal.style.justifyContent = 'center';
    purchaseModal.style.alignItems = 'center';
    purchaseModal.style.zIndex = '1001';

    const modalContent = document.createElement('div');
    modalContent.style.backgroundColor = 'white';
    modalContent.style.padding = '30px';
    modalContent.style.borderRadius = '10px';
    modalContent.style.textAlign = 'center';
    modalContent.style.maxWidth = '400px';
    modalContent.style.width = '90%';
    modalContent.style.boxShadow = '0 4px 12px rgba(108, 92, 231, 0.3)';

    // 添加标题和描述
    const title = document.createElement('h3');
    title.textContent = '哎呀 看来你需要找专业人士加点buff了';
    title.style.color = '#6c5ce7';
    title.style.margin = '0 0 20px 0';
    title.style.fontSize = '18px';
    title.style.lineHeight = '1.4';
    modalContent.appendChild(title);

    // 添加企业微信二维码容器
    const qrContainer = document.createElement('div');
    qrContainer.style.margin = '0 auto 20px auto';
    qrContainer.style.width = '200px';
    qrContainer.style.height = '200px';
    qrContainer.style.display = 'flex';
    qrContainer.style.justifyContent = 'center';
    qrContainer.style.alignItems = 'center';
    qrContainer.style.border = '1px solid #eee';
    qrContainer.style.borderRadius = '8px';
    qrContainer.style.background = 'white';

    // 创建二维码图片
    const qrCode = document.createElement('img');
    qrCode.src = 'https://res.gaodunwangxiao.com/tools/2025-10-24/73977960_79c93868-0160-4827-b2f0-5f679e51c73c.jpg';
    qrCode.alt = '企业微信二维码';
    qrCode.style.width = '180px';
    qrCode.style.height = '180px';
    qrCode.style.objectFit = 'contain';
    qrContainer.appendChild(qrCode);
    modalContent.appendChild(qrContainer);

    // 添加二维码说明文本
    const qrText = document.createElement('p');
    qrText.textContent = '长按识别二维码，添加企业微信获取专业指导';
    qrText.style.color = '#666';
    qrText.style.fontSize = '14px';
    qrText.style.marginBottom = '25px';
    modalContent.appendChild(qrText);

    // 添加关闭按钮
    const closeButton = document.createElement('button');
    closeButton.textContent = '关闭';
    closeButton.style.background = 'linear-gradient(135deg, #6c5ce7, #8e44ad)';
    closeButton.style.color = 'white';
    closeButton.style.border = 'none';
    closeButton.style.padding = '12px 30px';
    closeButton.style.borderRadius = '25px';
    closeButton.style.cursor = 'pointer';
    closeButton.style.fontSize = '16px';
    closeButton.style.fontWeight = 'bold';
    closeButton.style.boxShadow = '0 4px 12px rgba(108, 92, 231, 0.4)';
    closeButton.style.width = '100%';

    // 添加悬停效果
    closeButton.onmouseover = function () {
        this.style.transform = 'translateY(-2px)';
        this.style.boxShadow = '0 6px 20px rgba(108, 92, 231, 0.5)';
        this.style.transition = 'all 0.3s ease';
    };

    closeButton.onmouseout = function () {
        this.style.transform = 'translateY(0)';
        this.style.boxShadow = '0 4px 12px rgba(108, 92, 231, 0.4)';
    };

    modalContent.appendChild(closeButton);

    // 添加动画样式到页面头部
    const styleId = 'purchase-modal-styles';
    let styleElement = document.getElementById(styleId);
    if (!styleElement) {
        styleElement = document.createElement('style');
        styleElement.id = styleId;
        document.head.appendChild(styleElement);
    }
    styleElement.textContent = `
        @keyframes modalPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }
        #purchase-modal { animation: modalPulse 3s infinite; }
        #purchase-modal svg { user-select: none; }
    `;

    purchaseModal.appendChild(modalContent);
    document.body.appendChild(purchaseModal);

    // 关闭按钮事件处理
    closeButton.onclick = function () {
        purchaseModal.remove();
    };

    // 更新埋点数据
    appState.analytics.purchasePrompts = (appState.analytics.purchasePrompts || 0) + 1;
}

// 显示成就
function showAchievement(achievement = null) {
    if (!appState.selectedCharacter) return;

    const character = characters[appState.selectedCharacter];

    // 如果没有传入具体成就，则显示最终成就
    if (!achievement) {
        achievement = character.achievements.final;
    }

    // 更新成就信息
    elements.achievementTitleText.textContent = `恭喜获得「${achievement.name}」`;
    elements.achievementDescription.textContent = achievement.description;
    elements.achievementIcon.textContent = achievement.icon;

    // 添加角色主题色
    elements.achievementIcon.className = `achievement-icon ${appState.selectedCharacter}-theme`;

    // 根据成就类型设置按钮文本
    if (achievement.name === character.achievements.final.name) {
        elements.restartJourneyBtn.textContent = '开启新的旅程';
    } else {
        elements.restartJourneyBtn.textContent = '继续闯关';
    }

    // 显示成就弹窗
    appState.currentStep = 'achievement';

    // 更新埋点数据
    appState.analytics.battleCompletion++;

    // 保存成就到本地存储
    saveAchievementToLocalStorage(achievement.name);
    saveToLocalStorage();

    // 更新UI
    updateUI();

    // 更新所有角色的进度显示
    updateAllCharacterProgress();
}

// 返回角色选择
function goBackToSelection() {
    appState.currentStep = 'selection';
    updateUI();
}

// 返回故事体验
function goBackToStory() {
    appState.currentStep = 'story';
    updateUI();
}

// 重启旅程或继续闯关
function restartJourney() {
    // 隐藏成就弹窗
    elements.achievementModal.classList.remove('active');

    const character = characters[appState.selectedCharacter];

    // 检查当前是否是最终成就
    const currentAchievementName = elements.achievementTitleText.textContent.match(/「(.*?)」/);
    const isFinalAchievement =
        currentAchievementName && currentAchievementName[1] === character.achievements.final.name;

    if (isFinalAchievement) {
        // 完成所有关卡后，重置游戏状态
        appState.currentStep = 'selection';
        appState.selectedCharacter = null;
        appState.currentStoryIndex = 0;
        appState.currentLevel = 1;
        appState.currentQuestionIndex = 0;
        appState.selectedOptions = [];
        appState.score = 0;
        appState.levelAttempts = {};
        appState.retryQuestions = [];
    } else {
        // 关卡完成后，继续到下一关卡
        appState.currentStep = 'battle';
        appState.currentLevel++;
        appState.currentQuestionIndex = 0;
    }

    // 更新UI
    updateUI();
}

// 更新UI
function updateUI() {
    // 隐藏所有步骤
    elements.characterSelection.classList.remove('active');
    elements.storyExperience.classList.remove('active');
    elements.battleMode.classList.remove('active');
    elements.achievementModal.classList.remove('active');

    // 根据当前步骤显示对应内容
    switch (appState.currentStep) {
        case 'selection':
            elements.characterSelection.classList.add('active');
            break;

        case 'story':
            elements.storyExperience.classList.add('active');
            updateStoryUI();
            break;

        case 'battle':
            elements.battleMode.classList.add('active');
            updateBattleUI();
            break;

        case 'achievement':
            elements.achievementModal.classList.add('active');
            break;
    }
}

// 流式文字输出效果
function typewriterEffect(element, text, characterInfo, callback) {
    // 如果characterInfo是函数，说明是旧的调用方式（第三个参数是callback）
    if (typeof characterInfo === 'function') {
        callback = characterInfo;
        characterInfo = null;
    }

    if (!element || !text) return;

    // 清除之前的打字机效果定时器
    if (appState.typewriterTimerId) {
        clearTimeout(appState.typewriterTimerId);
        appState.typewriterTimerId = null;
    }

    // 清空元素内容
    element.innerHTML = '';

    let charIndex = 0;
    const speed = 30; // 每个字符的延迟时间（毫秒）

    function typeNextChar() {
        if (charIndex < text.length) {
            // 检查是否匹配到角色名字的起始位置
            let isCharacterName = false;
            let characterNameLength = 0;

            if (characterInfo && characterInfo.name) {
                const remainingText = text.substring(charIndex);
                if (remainingText.startsWith(characterInfo.name)) {
                    isCharacterName = true;
                    characterNameLength = characterInfo.name.length;
                }
            }

            if (isCharacterName) {
                // 创建带样式的角色名字span
                const nameSpan = document.createElement('span');
                nameSpan.className = characterInfo.className;
                nameSpan.textContent = characterInfo.name;
                element.appendChild(nameSpan);

                // 跳过整个角色名字的长度
                charIndex += characterNameLength;
                appState.typewriterTimerId = setTimeout(typeNextChar, speed * characterNameLength);
            } else {
                // 普通字符逐个输出
                let currentChar = text.charAt(charIndex);
                let charElement = document.createElement('span');

                charElement.textContent = currentChar;
                charElement.style.display = 'inline';
                charElement.style.whiteSpace = 'pre-wrap';

                element.appendChild(charElement);
                charIndex++;
                appState.typewriterTimerId = setTimeout(typeNextChar, speed);
            }
        } else {
            // 文本输出完成后调用回调函数
            if (typeof callback === 'function') {
                callback();
            }
        }
    }

    // 开始打字效果
    typeNextChar();
}

// 根据角色获取关键术语
function getTechTermsByCharacter(characterId) {
    const techTermsMap = {
        cyber: ['人工智能', '机器学习', '神经网络', '算法', '数据挖掘', '深度学习', '代码', '编程'],
        heritage: ['非遗', '传统工艺', '文化遗产', '手工艺', '戏曲', '书法', '国画', '传承'],
        space: ['宇宙', '星球', '黑洞', '星系', '太空站', '航天', '天文', '行星'],
        math: ['数学', '几何', '代数', '概率', '统计', '数列', '方程', '计算'],
    };

    return techTermsMap[characterId] || [];
}

// 更新故事UI
function updateStoryUI() {
    if (!appState.selectedCharacter) return;

    const character = characters[appState.selectedCharacter];
    const storySection = character.story[appState.currentStoryIndex];

    // 更新故事标题 - 优化为更具吸引力的文案
    const titleMap = {
        cyber: `开启Cyber侦探的数字冒险`,
        heritage: `开启非遗守护人的文化传承之旅`,
        space: `开启星球开拓者的星际探索`,
        math: `开启数学探索家的人生之旅`,
    };

    // 如果找不到对应角色的标题，使用默认格式
    const storyTitle = titleMap[appState.selectedCharacter] || `开启${character.name}的精彩旅程`;
    elements.storyTitle.textContent = storyTitle;

    // 角色名字和对应的CSS类映射
    const characterNameMap = {
        cyber: { name: 'Cyber侦探', className: 'cyber-name' },
        heritage: { name: '非遗守护人', className: 'heritage-name' },
        space: { name: '星球开拓者', className: 'space-name' },
        math: { name: '数学探索家', className: 'math-name' },
    };

    // 获取当前角色信息
    const characterInfo = characterNameMap[appState.selectedCharacter];

    // 使用流式文字输出效果更新故事内容
    typewriterEffect(elements.storyNarration, storySection.text, characterInfo, () => {
        // 文本输出完成后执行的操作
        // 例如显示选择项或继续按钮
        // 清除之前的选择项
        elements.storyChoices.innerHTML = '';

        // 隐藏/显示继续按钮
        if (storySection.next) {
            elements.nextStoryBtn.classList.remove('hidden');
        } else {
            elements.nextStoryBtn.classList.add('hidden');
        }
    });
}

// 更新战斗UI
function updateBattleUI() {
    if (!appState.selectedCharacter) return;

    const character = characters[appState.selectedCharacter];
    const currentLevel = character.levels[appState.currentLevel - 1];

    // 获取battle-header元素
    const battleHeader = elements.battleMode.querySelector('.battle-header');

    // 获取角色图标元素
    const characterIcon = document.getElementById('character-icon');

    // 角色图标映射表 - 使用更有趣、更具特色的表情符号
    const characterIcons = {
        cyber: {
            1: '🕵️‍♂️', // 数字初入者 - 侦探形象
            2: '💻', // 数字进阶 - 专注工作的电脑专家
            3: '🔐', // 数字大师 - 网络安全专家
            default: '👨‍💻', // 默认科技达人
        },
        heritage: {
            1: '🎭', // 文化初入者 - 戏剧面具（代表文化多样性）
            2: '📜', // 文化传承 - 古老卷轴
            3: '🏯', // 文化大师 - 古建筑守护者
            default: '🧙‍♂️', // 默认文化守护者
        },
        space: {
            1: '🚀', // 星际初入者 - 火箭发射
            2: '👨‍🚀', // 星际探索 - 宇航员出舱
            3: '🪐', // 星际大师 - 行星探索者
            default: '🌠', // 默认太空异象
        },
        math: {
            1: '🧮', // 数学初入者 - 老式计算器
            2: '🔬', // 数学进阶 - 科学探索
            3: '🧠', // 数学大师 - 智慧大脑
            default: '📊', // 默认数据分析师
        },
        default: {
            default: '🧩', // 默认拼图图标（代表探索未知）
        },
    };

    // 设置角色图标
    if (characterIcon) {
        const characterMap = characterIcons[appState.selectedCharacter] || characterIcons.default;
        const icon = characterMap[appState.currentLevel] || characterMap.default;
        characterIcon.textContent = icon;

        // 根据角色类型设置不同的图标背景颜色
        if (appState.selectedCharacter === 'cyber') {
            characterIcon.style.background = 'linear-gradient(135deg, rgba(0, 188, 212, 0.2), rgba(33, 150, 243, 0.2))';
            characterIcon.style.borderColor = 'rgba(0, 188, 212, 0.5)';
        } else if (appState.selectedCharacter === 'heritage') {
            characterIcon.style.background = 'linear-gradient(135deg, rgba(255, 193, 7, 0.2), rgba(255, 152, 0, 0.2))';
            characterIcon.style.borderColor = 'rgba(255, 193, 7, 0.5)';
        } else if (appState.selectedCharacter === 'space') {
            characterIcon.style.background =
                'linear-gradient(135deg, rgba(156, 39, 176, 0.2), rgba(103, 58, 183, 0.2))';
            characterIcon.style.borderColor = 'rgba(156, 39, 176, 0.5)';
        } else if (appState.selectedCharacter === 'math') {
            characterIcon.style.background = 'linear-gradient(135deg, rgba(76, 175, 80, 0.2), rgba(0, 150, 136, 0.2))';
            characterIcon.style.borderColor = 'rgba(76, 175, 80, 0.5)';
        } else {
            characterIcon.style.background =
                'linear-gradient(135deg, rgba(108, 99, 255, 0.2), rgba(142, 68, 173, 0.2))';
            characterIcon.style.borderColor = 'rgba(255, 255, 255, 0.3)';
        }
    }

    // 检查是否为cyber侦探的第一个关卡
    if (appState.selectedCharacter === 'cyber' && appState.currentLevel === 1) {
        battleHeader.classList.add('cyber-first-level');
    } else {
        battleHeader.classList.remove('cyber-first-level');
    }

    // 如果有错题需要重练，则优先显示错题
    let question;
    if (appState.retryQuestions.length > 0) {
        question = appState.retryQuestions[0];
    } else {
        question = currentLevel.questions[appState.currentQuestionIndex];
    }

    // 更新关卡标题
    if (elements.levelTitle && currentLevel.title) {
        elements.levelTitle.textContent = currentLevel.title;
    }

    // 更新关卡描述
    if (elements.levelDescription && currentLevel.description) {
        elements.levelDescription.textContent = currentLevel.description;
    }

    // 隐藏人生目标元素
    if (elements.levelGoal) {
        elements.levelGoal.classList.add('hidden');
    }

    // 完全隐藏battle-title元素，不再显示'知识挑战'字样
    if (elements.battleTitle) {
        elements.battleTitle.classList.add('hidden');
    }

    // 更新进度指示器
    if (appState.retryQuestions.length > 0) {
        // 错题模式：显示当前在重练第几道错题
        const totalRetryQuestions = appState.retryQuestions.length;
        elements.currentQuestion.textContent = `错题重练 1`;
        elements.totalQuestions.textContent = totalRetryQuestions;
    } else {
        // 正常模式：按照关卡总题数和当前题目索引显示
        elements.currentQuestion.textContent = appState.currentQuestionIndex + 1;
        elements.totalQuestions.textContent = currentLevel.questions.length;
    }

    // 更新题目内容
    const questionContentElement = elements.questionContainer.querySelector('.question-content');
    if (questionContentElement) {
        questionContentElement.textContent = question.content;
    } else {
        // 回退方案，确保旧版HTML也能正常工作
        elements.questionContainer.textContent = question.content;
    }

    // 清除之前的选项
    elements.optionsContainer.innerHTML = '';

    // 添加选项
    question.options.forEach((option, index) => {
        const optionElement = document.createElement('div');
        optionElement.className = 'option';
        optionElement.textContent = option;
        optionElement.addEventListener('click', () => selectAnswer(index));
        elements.optionsContainer.appendChild(optionElement);
    });

    // 彻底清除并隐藏反馈内容，确保新题目不显示任何前序题目的解析或提示信息
    if (elements.feedback) {
        elements.feedback.innerHTML = ''; // 清空所有内容
        elements.feedback.classList.add('hidden'); // 添加隐藏类
        elements.feedback.style.display = 'none'; // 强制隐藏
        // 移除特定类而不是重置整个className，避免影响基础样式
        elements.feedback.classList.remove('correct', 'incorrect');
    }

    // 隐藏下一题按钮
    if (elements.nextQuestionBtn) {
        elements.nextQuestionBtn.classList.add('hidden');
    }
}

// 保存到本地存储
function saveToLocalStorage() {
    try {
        localStorage.setItem('gameState', JSON.stringify(appState));
    } catch (error) {
        console.error('保存游戏状态失败:', error);
    }
}

// 从本地存储加载
function loadFromLocalStorage() {
    try {
        const savedState = localStorage.getItem('gameState');
        if (savedState) {
            const parsedState = JSON.parse(savedState);
            // 加载需要持久化的状态
            if (parsedState.analytics) {
                appState.analytics = parsedState.analytics;
            }
            // 加载关卡相关的状态
            if (typeof parsedState.currentLevel !== 'undefined') {
                appState.currentLevel = parsedState.currentLevel;
            }
            if (parsedState.levelAttempts) {
                appState.levelAttempts = parsedState.levelAttempts;
            }
            if (parsedState.retryQuestions) {
                appState.retryQuestions = parsedState.retryQuestions;
            }
        }
    } catch (error) {
        console.error('加载游戏状态失败:', error);
    }
}

// 保存成就到本地存储
function saveAchievementToLocalStorage(achievementName) {
    try {
        let achievements = JSON.parse(localStorage.getItem('achievements') || '[]');
        if (!achievements.includes(achievementName)) {
            achievements.push(achievementName);
            localStorage.setItem('achievements', JSON.stringify(achievements));
        }
    } catch (error) {
        console.error('保存成就失败:', error);
    }
}

// 初始化应用
initApp();

// ============ 分享功能 ============
const shareModal = document.getElementById('share-modal');
const shareCloseBtn = shareModal.querySelector('.share-close');
const shareLinkInput = document.getElementById('share-link-input');
const copyLinkBtn = document.getElementById('copy-link-btn');
const qrcodeContainer = document.getElementById('qrcode-container');

let qrCodeInstance = null;

// 检测是否为移动端
function isMobile() {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
}

// 检测是否在微信内置浏览器
function isWechat() {
    return /MicroMessenger/i.test(navigator.userAgent);
}

// 打开分享弹窗
function openShareModal() {
    const shareLink = window.location.href;
    
    // 移动端处理
    if (isMobile()) {
        if (isWechat()) {
            // 在微信内置浏览器中，提示用户使用右上角分享
            alert('📱 请点击右上角 ··· 菜单\n选择"分享给朋友"或"分享到朋友圈"\n\n分享后即可解锁完整解析！');
            // 直接解锁（因为无法检测是否真的分享了）
            setTimeout(() => {
                unlockFullExplanation();
            }, 1000);
            return;
        } else {
            // 非微信移动端浏览器，尝试唤起微信分享
            try {
                // 尝试使用Web Share API（现代移动浏览器支持）
                if (navigator.share) {
                    navigator.share({
                        title: '逻辑推理游戏 - 邀请你一起挑战！',
                        text: '快来一起玩这个有趣的逻辑推理游戏吧！',
                        url: shareLink
                    }).then(() => {
                        // 分享成功，解锁完整解析
                        soundEffects.playStoryProgress();
                        unlockFullExplanation();
                    }).catch((err) => {
                        // 用户取消分享或分享失败
                        console.log('分享取消或失败:', err);
                    });
                    return;
                } else {
                    // 不支持Web Share API，提示复制链接
                    alert('📱 您的浏览器不支持直接分享\n\n请复制以下链接分享给好友：\n' + shareLink);
                }
            } catch (err) {
                console.error('分享失败:', err);
                alert('📱 请复制链接分享给好友：\n' + shareLink);
            }
        }
    }
    
    // PC端或降级方案：显示二维码分享弹窗
    shareLinkInput.value = shareLink;
    generateQRCode(shareLink);
    shareModal.classList.add('active');
    soundEffects.playStoryProgress();
}

// 关闭分享弹窗
function closeShareModal() {
    shareModal.classList.remove('active');
    
    // 清除二维码
    if (qrCodeInstance) {
        qrcodeContainer.innerHTML = '';
        qrCodeInstance = null;
    }
}

// 生成二维码
function generateQRCode(url) {
    // 清除旧的二维码
    if (qrCodeInstance) {
        qrcodeContainer.innerHTML = '';
    }
    
    // 检查QRCode库是否加载
    if (typeof QRCode === 'undefined') {
        console.error('QRCode库未加载');
        qrcodeContainer.innerHTML = '<p style="color: #e74c3c;">二维码生成失败</p>';
        return;
    }
    
    try {
        qrCodeInstance = new QRCode(qrcodeContainer, {
            text: url,
            width: 200,
            height: 200,
            colorDark: '#000000',
            colorLight: '#ffffff',
            correctLevel: QRCode.CorrectLevel.H
        });
    } catch (error) {
        console.error('生成二维码失败:', error);
        qrcodeContainer.innerHTML = '<p style="color: #e74c3c;">二维码生成失败</p>';
    }
}

// 复制链接
function copyShareLink() {
    shareLinkInput.select();
    shareLinkInput.setSelectionRange(0, 99999); // 移动端兼容
    
    try {
        // 尝试使用现代API
        if (navigator.clipboard && window.isSecureContext) {
            navigator.clipboard.writeText(shareLinkInput.value).then(() => {
                showCopySuccess();
            }).catch(err => {
                // 降级到旧方法
                fallbackCopy();
            });
        } else {
            // 降级到旧方法
            fallbackCopy();
        }
    } catch (err) {
        console.error('复制失败:', err);
        alert('复制失败,请手动复制链接');
    }
}

// 降级复制方法
function fallbackCopy() {
    try {
        const successful = document.execCommand('copy');
        if (successful) {
            showCopySuccess();
        } else {
            alert('复制失败,请手动复制链接');
        }
    } catch (err) {
        console.error('降级复制也失败:', err);
        alert('复制失败,请手动复制链接');
    }
}

// 显示复制成功提示
function showCopySuccess() {
    const originalText = copyLinkBtn.textContent;
    copyLinkBtn.textContent = '✓ 已复制';
    copyLinkBtn.style.background = 'linear-gradient(135deg, #2ecc71, #27ae60)';
    
    setTimeout(() => {
        copyLinkBtn.textContent = originalText;
        copyLinkBtn.style.background = '';
    }, 2000);
    
    // 播放成功音效
    soundEffects.playStoryProgress();
}

// 解锁完整解析
function unlockFullExplanation() {
    const levelKey = `level${appState.currentLevel}`;
    const wrongCount = appState.wrongAnswersCount[levelKey];
    
    if (wrongCount > 3) {
        // 获取当前题目信息
        const character = characters[appState.selectedCharacter];
        const currentLevel = character.levels[appState.currentLevel - 1];
        const currentQuestion = currentLevel.questions[appState.currentQuestionIndex];
        
        // 生成并显示完整解析
        const detailedExplanation = generateDetailedExplanation(
            currentQuestion.explanation,
            currentQuestion.question
        );
        
        const explanationElement = elements.feedback.querySelector('.detailed-explanation');
        const lockedElement = elements.feedback.querySelector('.share-locked-explanation');
        
        if (explanationElement && lockedElement) {
            explanationElement.innerHTML = detailedExplanation;
            lockedElement.innerHTML = '<div class="unlocked-explanation"><p>🎉 恭喜!您已成功解锁完整解析!</p></div>';
            lockedElement.classList.remove('share-locked-explanation');
        }
        
        // 播放成功音效
        soundEffects.playStoryProgress();
    }
    
    // 关闭分享弹窗
    closeShareModal();
}

// 绑定事件监听
const unlockExplanationBtn = document.getElementById('unlock-explanation-btn');

shareCloseBtn.addEventListener('click', closeShareModal);
copyLinkBtn.addEventListener('click', copyShareLink);
unlockExplanationBtn.addEventListener('click', unlockFullExplanation);

// 点击弹窗背景关闭
shareModal.addEventListener('click', (e) => {
    if (e.target === shareModal) {
        closeShareModal();
    }
});

// ESC键关闭弹窗
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && shareModal.classList.contains('active')) {
        closeShareModal();
    }
});
