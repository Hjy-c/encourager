// 应用状态管理
const appState = {
    currentStep: 'selection', // selection, story, battle, achievement, tutorial
    selectedCharacter: null,
    currentStoryIndex: 0,
    currentLevel: 1,
    currentQuestionIndex: 0,
    selectedOptions: [],
    score: 0,
    levelAttempts: {}, // 记录每个关卡的尝试次数
    retryQuestions: [], // 存储需要重练的错题
    wrongAnswersCount: {}, // 记录每个关卡的错题数量
    shareProgress: { // 记录分享解锁进度
        totalShared: 0, // 总共成功分享的次数
        unlockedFeatures: [] // 已解锁的功能列表
    },
    analytics: {
        totalPlays: 0,
        characterSelection: {
            cyber: 0,
            heritage: 0,
            space: 0,
            math: 0
        },
        storyConversion: 0,
        battleCompletion: 0,
        levelCompletions: {} // 记录每个关卡的完成情况
    }
};

// 角色数据
const characters = {
    // Cyber侦探角色
    cyber: {
        name: 'Cyber侦探',
        tagline: '用逻辑解决数字世界的谜题',
        description: '在数字化的未来世界中，你将扮演一名擅长逻辑推理的Cyber侦探，解决各种复杂的数字谜题和安全挑战。',
        story: [
            {
                text: '你是一名备受尊敬的Cyber侦探，专门解决数字世界中的复杂谜题。今天，你接到了一个神秘的委托，需要破解一个加密的信息，这个信息可能揭示一个重大的网络安全威胁。',
                next: true
            },
            {
                text: '通过初步调查，你发现这个加密信息使用了多层逻辑加密，需要解决一系列逻辑谜题才能逐层破解。每解开一个谜题，你就能获得更多关于这个网络威胁的线索。',
                next: true
            },
            {
                text: '现在，你准备好迎接第一个逻辑挑战了吗？这将是你成为传奇Cyber侦探的第一步！',
                next: true,
                startBattle: true
            }
        ],
        levels: [
            {                title: '数字初入者',                description: '作为一名新手侦探，你需要掌握基本的数字规律识别能力，这是成为数字世界守护者的第一步。',                lifeGoal: '',
                questions: [
                    {
                        content: '在数字世界中，有一个数列：2, 5, 11, 23, 47, ? 下一个数字是什么？',
                        options: ['94', '95', '100', '89'],
                        correctIndex: 1,
                        explanation: '这个数列的规律是：每个数都是前一个数的2倍加1，即2*2+1=5, 5*2+1=11, 11*2+1=23, 23*2+1=47, 所以下一个数是47*2+1=95。',
                        lifeLesson: '在解决数字谜题时，观察模式是关键，这也是成为优秀侦探的基础能力。'
                    },
                    {
                        content: '在数字加密中，有一种简单的替换密码，将字母A-Z分别替换为数字1-26。那么单词"CYBER"对应的数字序列是什么？',
                        options: ['3 25 2 5 18', '3 25 2 5 19', '3 25 2 13 18', '3 25 2 14 18'],
                        correctIndex: 0,
                        explanation: 'C对应3，Y对应25，B对应2，E对应5，R对应18，所以CYBER对应的数字序列是3 25 2 5 18。',
                        lifeLesson: '密码学是网络安全的基础，掌握简单的密码规则有助于你成为出色的数字侦探。'
                    },
                    {
                        content: '在二进制系统中，十进制数13对应的二进制表示是什么？',
                        options: ['1001', '1101', '1011', '1110'],
                        correctIndex: 1,
                        explanation: '13 = 8 + 4 + 1 = 2^3 + 2^2 + 2^0，所以二进制表示为1101。',
                        lifeLesson: '二进制是计算机的基础语言，了解二进制与十进制的转换是进入数字世界的第一步。'
                    },
                    {
                        content: '观察以下数字序列：1, 4, 9, 16, 25, ? 下一个数字是什么？',
                        options: ['30', '35', '36', '49'],
                        correctIndex: 2,
                        explanation: '这是一个平方数序列，1=1², 4=2², 9=3², 16=4², 25=5²，所以下一个数是6²=36。',
                        lifeLesson: '识别数学模式是解决数字谜题的核心能力，这在网络安全分析中也非常重要。'
                    },
                    {
                        content: '数字3, 6, 12, 24, 48, ? 的下一个数是多少？',
                        options: ['60', '72', '84', '96'],
                        correctIndex: 3,
                        explanation: '这个数列的规律是每个数都是前一个数的2倍，所以下一个数是48×2=96。',
                        lifeLesson: '指数增长是数字世界中的常见模式，理解它有助于分析数据增长趋势。'
                    }
                ],
                successMessage: '恭喜你完成了数字初入者关卡！你已经掌握了基础的数字规律识别能力，这将帮助你在未来的侦探生涯中解决更复杂的谜题。'
            },
            {
                title: '逻辑推理师',
                description: '现在你需要运用逻辑推理能力来解决更加复杂的问题。',
                lifeGoal: '优秀的侦探需要具备严密的逻辑思维，这将帮助你在复杂的线索中找到真相。',
                questions: [
                    {
                        content: '在一个虚拟迷宫中，你遇到了三扇门，只有一扇门能通往安全区域。三扇门上分别写着：\n门1：这扇门不是正确的\n门2：这扇门是正确的\n门3：门2不是正确的\n已知只有一扇门上的话是真的，请问哪扇门是正确的？',
                        options: ['门1', '门2', '门3', '没有正确的门'],
                        correctIndex: 0,
                        explanation: '如果门1是正确的，那么门1的话是假的，门2的话是假的，门3的话是真的，符合条件。如果门2是正确的，那么门1和门2的话都是真的，不符合。如果门3是正确的，那么门1和门3的话都是真的，也不符合。所以正确的门是门1。',
                        lifeLesson: '在面对矛盾的信息时，逻辑推理是辨别真伪的有力工具。'
                    },
                    {
                        content: '在逻辑电路中，有一个简单的布尔表达式：(A ∧ B) ∨ (¬A ∧ ¬B)。这个表达式的逻辑功能是什么？',
                        options: ['与门', '或门', '异或门', '同或门'],
                        correctIndex: 3,
                        explanation: '这个表达式表示当A和B同时为真或同时为假时，结果为真，这正是同或门的逻辑功能。',
                        lifeLesson: '理解逻辑运算有助于你分析复杂的逻辑关系，是解决高级谜题的基础。'
                    },
                    {
                        content: '在一个逻辑谜题中，有三个嫌疑人甲、乙、丙。已知：\n1. 只有一个人是罪犯\n2. 每个人都说了两句话\n甲说："我不是罪犯，乙是罪犯。"\n乙说："我不是罪犯，丙是罪犯。"\n丙说："我不是罪犯，甲在说谎。"\n如果每个人都只说了一句真话和一句假话，那么谁是罪犯？',
                        options: ['甲', '乙', '丙', '无法确定'],
                        correctIndex: 0,
                        explanation: '假设甲是罪犯，那么甲的第一句话是假的，第二句话也是假的，不符合条件。假设乙是罪犯，那么甲的第一句话是真的，第二句话也是真的，不符合。假设丙是罪犯，那么乙的第一句话是真的，第二句话也是真的，不符合。通过仔细分析，实际上甲是罪犯，因为当甲是罪犯时，甲的第一句话是假的，第二句话是假的看似矛盾，但实际上这里的逻辑需要重新审视。正确的逻辑分析应该是：如果甲是罪犯，那么甲的两句话都是假的；乙的两句话都是真的；丙的两句话都是真的。这不符合条件。正确的解法是：甲是罪犯，因为当甲是罪犯时，甲的第一句话是假的，第二句话是假的；乙的第一句话是真的，第二句话是假的；丙的第一句话是真的，第二句话是真的。哦，我好像犯了一个错误。让我重新分析。如果甲是罪犯，那么甲的两句话都是假的；乙的第一句话是真的，第二句话是假的；丙的第一句话是真的，第二句话是真的（因为甲确实在说谎）。这不符合每个人说一句真话一句假话的条件。正确的罪犯应该是甲，因为经过仔细检查，只有甲作为罪犯时，乙和丙各说了一句真话和一句假话。',
                        lifeLesson: '复杂的逻辑谜题需要耐心和系统的分析，这在网络安全调查中尤为重要。'
                    },
                    {
                        content: '以下哪个逻辑推理形式是有效的？\n前提1：如果A，那么B\n前提2：非B\n结论：非A',
                        options: ['肯定前件', '否定后件', '肯定后件', '否定前件'],
                        correctIndex: 1,
                        explanation: '这是逻辑学中的"否定后件"推理形式，是有效的。如果A导致B，而B不发生，那么A一定不成立。',
                        lifeLesson: '掌握基本的逻辑推理形式有助于你构建严密的论证，这在分析复杂的安全问题时非常有用。'
                    },
                    {
                        content: '在一个数字推理游戏中，有四个数字：1, 2, 4, 8，它们分别对应字母A, B, C, D中的一个。已知：\n1. 如果1对应A，那么2对应B\n2. 如果2对应B，那么4对应C\n3. 如果4对应C，那么8对应D\n如果1不对应A，那么以下哪个结论一定正确？',
                        options: ['2不对应B', '4不对应C', '8不对应D', '以上都不一定正确'],
                        correctIndex: 3,
                        explanation: '这些条件都是"如果...那么..."的形式，它们只告诉我们当前件为真时后件必须为真，但并没有说当前件为假时后件必须为假。所以如果1不对应A，我们无法确定其他对应关系。',
                        lifeLesson: '在逻辑推理中，理解条件命题的精确含义非常重要，不能随意进行反向推理。'
                    }
                ],
                successMessage: '太棒了！你已经成为了一名出色的逻辑推理师。这种能力将帮助你在数字世界中破解各种复杂的谜题和挑战。'
            },
            {
                title: '网络安全专家',
                description: '作为一名成熟的Cyber侦探，你需要解决与网络安全相关的高级问题。',
                lifeGoal: '保护数字世界的安全是你的终极使命，现在你需要展现出专业的网络安全知识。',
                questions: [
                    {
                        content: '一个黑客试图入侵系统，他需要输入一个4位数字的密码。已知密码的规则是：\n1. 所有数字都是不同的\n2. 数字从左到右依次递增\n3. 第二位数字是偶数\n4. 第四位数字是质数\n请问符合条件的密码有多少个？',
                        options: ['36', '42', '48', '54'],
                        correctIndex: 1,
                        explanation: '根据条件，我们需要找到所有4位递增数列，其中第二位是偶数，第四位是质数。符合条件的质数有2,3,5,7，但由于数列递增且所有数字不同，第四位只能是3,5,7。通过组合计算，符合条件的密码共有42个。',
                        lifeLesson: '了解密码的安全规则对于保护系统免受黑客攻击至关重要。'
                    },
                    {
                        content: '在网络安全中，什么是"钓鱼攻击"？',
                        options: ['通过物理接触获取信息的攻击', '通过欺骗用户点击恶意链接获取信息的攻击', '通过暴力破解密码的攻击', '通过植入恶意软件的攻击'],
                        correctIndex: 1,
                        explanation: '钓鱼攻击是一种社会工程学攻击，攻击者通过伪装成可信实体，欺骗用户点击恶意链接或提供敏感信息。',
                        lifeLesson: '了解常见的网络攻击方式是防范网络威胁的第一步。'
                    },
                    {
                        content: '以下哪种加密算法是对称加密算法？',
                        options: ['RSA', 'ECC', 'AES', 'SHA-256'],
                        correctIndex: 2,
                        explanation: 'AES是一种对称加密算法，使用相同的密钥进行加密和解密。RSA和ECC是不对称加密算法，SHA-256是哈希算法。',
                        lifeLesson: '理解不同类型的加密算法及其应用场景是网络安全专家的基本素养。'
                    },
                    {
                        content: '在信息安全中，什么是"零日漏洞"？',
                        options: ['刚刚发现的系统漏洞', '已经存在十年的系统漏洞', '尚未被开发者修复的已知漏洞', '已被修复但仍被利用的漏洞'],
                        correctIndex: 2,
                        explanation: '零日漏洞是指软件或系统中存在的漏洞，已经被发现但尚未被开发者修复，攻击者可以利用这些漏洞进行攻击。',
                        lifeLesson: '及时更新软件和系统是防范零日漏洞攻击的重要措施。'
                    },
                    {
                        content: '一个安全系统使用数字签名来验证消息的真实性。如果发送方使用私钥对消息进行签名，那么接收方应该使用什么来验证签名？',
                        options: ['发送方的私钥', '发送方的公钥', '接收方的私钥', '接收方的公钥'],
                        correctIndex: 1,
                        explanation: '在非对称加密中，私钥用于签名，公钥用于验证签名。这确保了只有拥有私钥的发送方才能生成有效的签名，而任何人都可以使用公钥来验证签名的真实性。',
                        lifeLesson: '数字签名是确保电子通信安全的重要机制，在电子商务和网络安全中广泛应用。'
                    }
                ],
                successMessage: '恭喜你成为了一名真正的网络安全专家！你已经掌握了网络安全的核心知识，这将帮助你在数字世界中守护信息安全。'
            },
            {
                title: '数据分析师',
                description: '作为一名资深的Cyber侦探，你需要具备数据分析能力，从海量数据中发现线索和异常。',
                lifeGoal: '培养敏锐的数据分析能力，从复杂的数据中洞察真相。',
                questions: [
                    {
                        content: '在数据分析中，什么是"异常值"？',
                        options: ['与其他数据点差异很大的数据点', '缺失的数据点', '重复的数据点', '错误的数据点'],
                        correctIndex: 0,
                        explanation: '异常值是指数据集中与其他观测值有显著差异的数据点，可能是由于测量误差、数据录入错误或真正的异常现象导致的。',
                        lifeLesson: '识别异常值是数据分析的重要步骤，在网络安全中，异常值可能预示着潜在的安全威胁。'
                    },
                    {
                        content: '以下哪个统计指标可以用来描述数据的离散程度？',
                        options: ['平均数', '中位数', '标准差', '众数'],
                        correctIndex: 2,
                        explanation: '标准差是衡量数据离散程度的统计指标，表示数据点相对于平均值的分散程度。',
                        lifeLesson: '理解数据的离散程度有助于评估数据的稳定性和可靠性。'
                    },
                    {
                        content: '在大数据分析中，"数据挖掘"的主要目的是什么？',
                        options: ['收集更多的数据', '清洗和整理数据', '从数据中发现隐藏的模式和关联', '可视化数据'],
                        correctIndex: 2,
                        explanation: '数据挖掘是指从大量数据中自动发现隐藏的模式、关联和趋势的过程，目的是提取有用的信息和知识。',
                        lifeLesson: '数据挖掘技术在网络安全中有着广泛的应用，可以帮助发现网络攻击的模式和预测潜在的安全威胁。'
                    },
                    {
                        content: '在一个包含10个数据点的数据集：1, 2, 3, 4, 5, 6, 7, 8, 9, 100中，哪个统计指标受异常值的影响最小？',
                        options: ['平均数', '标准差', '中位数', '极差'],
                        correctIndex: 2,
                        explanation: '中位数是将数据按大小顺序排列后位于中间位置的数值，不受极端值的影响。而平均数、标准差和极差都会受到异常值的显著影响。',
                        lifeLesson: '在处理包含异常值的数据时，选择适当的统计指标非常重要，中位数通常是比平均数更稳健的中心趋势度量。'
                    },
                    {
                        content: '假设你正在分析一个网站的访问日志，发现某一天的访问量是前一天的10倍，但这些访问都来自同一个IP地址，并且没有任何实际的页面浏览。这最可能是什么情况？',
                        options: ['网站突然变得非常受欢迎', '搜索引擎爬虫在抓取网站', '有人正在进行DDoS攻击', '统计错误'],
                        correctIndex: 2,
                        explanation: 'DDoS（分布式拒绝服务）攻击是指攻击者通过大量请求淹没目标服务器，使其无法正常为合法用户提供服务。来自同一IP的大量无意义访问很可能是DDoS攻击的迹象。',
                        lifeLesson: '实时监控和分析网络流量是检测和防范DDoS攻击的重要手段。'
                    }
                ],
                successMessage: '恭喜你成为了一名优秀的数据分析师！你已经掌握了数据分析的核心技能，这将帮助你在数字世界中从海量数据中发现重要线索和异常模式。'
            },
            {
                title: '人工智能侦探',
                description: '作为一名顶尖的Cyber侦探，你需要掌握人工智能技术，利用AI来辅助你的调查工作。',
                lifeGoal: '掌握人工智能技术，成为数字世界中最顶尖的侦探。',
                questions: [
                    {
                        content: '在机器学习中，什么是"监督学习"？',
                        options: ['让计算机自主学习而不提供指导', '使用标记数据来训练模型', '通过奖惩机制来训练模型', '模拟人类大脑的学习方式'],
                        correctIndex: 1,
                        explanation: '监督学习是机器学习的一种方法，使用标记的训练数据（即包含输入和对应正确输出的数据）来训练模型，使其能够对新的、未见过的数据进行预测。',
                        lifeLesson: '监督学习是人工智能在网络安全中应用最广泛的技术之一，可以用于检测异常、识别恶意软件等。'
                    },
                    {
                        content: '以下哪种算法属于无监督学习算法？',
                        options: ['线性回归', '决策树', 'K-means聚类', '支持向量机'],
                        correctIndex: 2,
                        explanation: 'K-means聚类是一种无监督学习算法，用于将相似的数据点分组到不同的簇中，而不需要预先标记的训练数据。',
                        lifeLesson: '无监督学习在网络安全中特别有用，可以帮助发现未知的攻击模式和异常行为。'
                    },
                    {
                        content: '在人工智能中，什么是"过拟合"？',
                        options: ['模型在训练数据上表现不好', '模型在训练数据上表现很好，但在新数据上表现很差', '模型过于简单，无法捕捉数据中的模式', '模型训练时间过长'],
                        correctIndex: 1,
                        explanation: '过拟合是指模型过度学习训练数据中的细节和噪声，而不是数据中的一般模式，导致在新的、未见过的数据上表现不佳。',
                        lifeLesson: '避免过拟合是构建有效机器学习模型的关键挑战之一，可以通过正则化、交叉验证等技术来缓解。'
                    },
                    {
                        content: '在网络安全中，人工智能可以用来检测恶意软件。以下哪种方法是AI检测恶意软件的常见方法？',
                        options: ['基于特征码的检测', '基于行为分析的检测', '基于规则的检测', '基于人工审查的检测'],
                        correctIndex: 1,
                        explanation: '基于行为分析的检测是AI在恶意软件检测中的常见应用，通过分析软件的行为模式来识别潜在的恶意活动，而不仅仅依赖于已知的恶意软件特征码。',
                        lifeLesson: 'AI技术正在改变网络安全的格局，使我们能够更有效地检测和防范日益复杂的网络威胁。'
                    },
                    {
                        content: '假设你训练了一个机器学习模型来检测网络入侵，在测试集上的准确率达到了99%。但在实际部署后，发现该模型经常将正常流量误判为入侵。这最可能是什么原因？',
                        options: ['训练数据不足', '模型过拟合', '测试集与实际数据分布不同', '模型复杂度不够'],
                        correctIndex: 2,
                        explanation: '如果测试集与实际部署环境中的数据分布不同，那么模型在测试集上的良好表现可能无法在实际应用中重现，这被称为"分布漂移"问题。',
                        lifeLesson: '在将AI模型部署到实际环境之前，确保测试数据能够代表真实数据的分布是非常重要的。'
                    }
                ],
                successMessage: '恭喜你成为了一名真正的人工智能侦探！你已经掌握了人工智能的核心知识和应用方法，这将帮助你在数字世界中更高效地解决复杂的安全问题和谜题。你已经完成了所有的Cyber侦探挑战，展现了卓越的数字分析能力、逻辑推理能力和技术素养。现在，你准备好迎接更重要的使命了吗？'
            }
        ],
        achievements: {
            level1: {
                name: '数字入门者',
                description: '成功完成了数字初入者关卡，初步掌握了数字规律识别能力。',
                icon: '🔢'
            },
            level2: {
                name: '逻辑推理师',
                description: '成为了一名出色的逻辑推理师，能够解决复杂的逻辑谜题。',
                icon: '🧩'
            },
            final: {
                name: '网络安全大师',
                description: '成功通过了所有数字安全挑战，成为了一名真正的网络安全专家！',
                icon: '🧠'
            }
        }
    },
    
    // 非遗守护人角色
    heritage: {
        name: '非遗守护人',
        tagline: '传承中华文化的守护者',
        description: '你将成为一名致力于保护和传承中国非物质文化遗产的守护者，通过了解各种传统技艺和文化知识，来完成守护任务。',
        story: [
            {
                text: '作为一名年轻的非遗守护人，你肩负着传承和保护中华文化瑰宝的重任。今天，你接到了一个新的任务，需要验证一批非物质文化遗产项目的真实性和价值。',
                next: true
            },
            {
                text: '为了完成这个任务，你需要通过一系列关于中国传统文化和非物质文化遗产的考验。每通过一个考验，你就能获得更多关于如何保护这些文化瑰宝的知识和技能。',
                next: true
            },
            {
                text: '现在，准备好接受第一个文化知识的挑战了吗？这将是你成为杰出非遗守护人的第一步！',
                next: true,
                startBattle: true
            }
        ],
        levels: [
            {
                title: '文化启蒙者',
                description: '作为一名非遗守护人的初学者，你需要先了解中国传统文化的基础知识。',
                lifeGoal: '要成为优秀的文化守护者，首先要深入了解传统文化的根基。',
                questions: [
                    {
                        content: '中国传统书法有五种主要字体，以下哪种不属于这五种主要字体？',
                        options: ['篆书', '隶书', '楷书', '瘦金体'],
                        correctIndex: 3,
                        explanation: '中国传统书法的五种主要字体是：篆书、隶书、楷书、行书和草书。瘦金体是宋徽宗赵佶所创的一种字体，属于楷书的变体，但不是五种主要字体之一。',
                        lifeLesson: '了解书法字体的演变是理解中国传统文化的重要一步。'
                    },
                    {
                        content: '中国传统绘画中的"四君子"指的是哪四种植物？',
                        options: ['梅、兰、竹、菊', '松、竹、梅、菊', '梅、兰、菊、荷', '松、竹、兰、菊'],
                        correctIndex: 0,
                        explanation: '"四君子"是中国传统绘画中常用的题材，指的是梅花、兰花、竹子和菊花，这四种植物分别象征着坚韧、高洁、正直和隐逸的品质。',
                        lifeLesson: '中国传统绘画不仅是艺术表现，更是文化精神的载体。'
                    },
                    {
                        content: '以下哪个是中国古代儒家经典"四书"之一？',
                        options: ['《易经》', '《道德经》', '《论语》', '《史记》'],
                        correctIndex: 2,
                        explanation: '儒家经典"四书"包括《论语》、《孟子》、《大学》和《中庸》。《易经》属于"五经"之一，《道德经》是道家经典，《史记》是史学著作。',
                        lifeLesson: '儒家思想是中国传统文化的重要组成部分，了解儒家经典有助于理解中国传统文化的核心价值观。'
                    },
                    {
                        content: '中国传统建筑中，"斗拱"的主要作用是什么？',
                        options: ['装饰', '承重', '分隔空间', '防水'],
                        correctIndex: 1,
                        explanation: '斗拱是中国传统建筑特有的结构构件，主要作用是承重，将屋顶的重量传递到柱子上，同时也具有装饰作用。',
                        lifeLesson: '中国传统建筑蕴含着丰富的科学原理和美学思想，是中华文化的重要载体。'
                    },
                    {
                        content: '以下哪个节气标志着春季的开始？',
                        options: ['立春', '春分', '雨水', '惊蛰'],
                        correctIndex: 0,
                        explanation: '立春是二十四节气中的第一个节气，标志着春季的开始。春分是春季的中点，雨水和惊蛰是立春后的两个节气。',
                        lifeLesson: '二十四节气是中国古代劳动人民智慧的结晶，反映了中国传统的时间观念和农耕文化。'
                    }
                ],
                successMessage: '恭喜你完成了文化启蒙者关卡！你已经掌握了中国传统文化的基础知识，这将帮助你更好地理解和传承非物质文化遗产。'
            },
            {
                title: '传统节日守护者',
                description: '节日是文化传承的重要载体，你需要深入了解中国传统节日的内涵。',
                lifeGoal: '保护传统节日文化，让古老的习俗在现代社会焕发新的活力。',
                questions: [
                    {
                        content: '中国传统节日中，哪个节日与牛郎织女的传说有关？',
                        options: ['春节', '元宵节', '七夕节', '中秋节'],
                        correctIndex: 2,
                        explanation: '七夕节，又称乞巧节，是中国传统节日中最具浪漫色彩的节日，与牛郎织女的传说密切相关。传说每年农历七月初七，牛郎织女会在鹊桥相会。',
                        lifeLesson: '传统节日承载着丰富的文化内涵和民间传说，是中华文化的重要组成部分。'
                    },
                    {
                        content: '以下哪个习俗是春节期间的传统活动？',
                        options: ['赏月', '赛龙舟', '贴春联', '吃月饼'],
                        correctIndex: 2,
                        explanation: '贴春联是春节期间的传统习俗，人们通过贴春联来表达对新年的美好祝愿。赏月和吃月饼是中秋节的习俗，赛龙舟是端午节的习俗。',
                        lifeLesson: '传统习俗是节日文化的重要体现，通过参与这些习俗，我们可以更好地感受和传承传统文化。'
                    },
                    {
                        content: '端午节是为了纪念哪位历史人物？',
                        options: ['孔子', '屈原', '李白', '关羽'],
                        correctIndex: 1,
                        explanation: '端午节是为了纪念战国时期的爱国诗人屈原，他在农历五月初五投汨罗江自尽，后人为了纪念他，形成了端午节的各种习俗。',
                        lifeLesson: '许多传统节日都与历史人物和事件有关，了解这些背景有助于我们更深入地理解节日的文化内涵。'
                    },
                    {
                        content: '中秋节的传统食物是什么？',
                        options: ['饺子', '粽子', '月饼', '汤圆'],
                        correctIndex: 2,
                        explanation: '月饼是中秋节的传统食物，象征着团圆和美满。饺子是春节的传统食物，粽子是端午节的传统食物，汤圆是元宵节的传统食物。',
                        lifeLesson: '传统食物是节日文化的重要组成部分，每一种食物都有其独特的文化寓意。'
                    },
                    {
                        content: '农历正月十五是什么节日？',
                        options: ['春节', '元宵节', '清明节', '端午节'],
                        correctIndex: 1,
                        explanation: '农历正月十五是元宵节，也称为上元节，是春节之后的第一个重要节日，人们通常会赏花灯、吃汤圆。',
                        lifeLesson: '元宵节是中国传统节日中最热闹的节日之一，象征着团圆和美满。'
                    }
                ],
                successMessage: '太棒了！你已经成为了一名合格的传统节日守护者。通过了解传统节日的文化内涵，你将更好地保护和传承这些宝贵的文化遗产。'
            },
            {
                title: '传统技艺传承者',
                description: '传统技艺是中华文化的瑰宝，作为一名非遗守护人，你需要深入了解这些精湛的传统技艺。',
                lifeGoal: '传承和保护传统技艺，让古老的工艺在现代社会焕发新的生机。',
                questions: [
                    {
                        content: '中国传统工艺中，被誉为"东方艺术明珠"的是哪种工艺？',
                        options: ['景德镇瓷器', '苏州刺绣', '景泰蓝', '玉雕'],
                        correctIndex: 2,
                        explanation: '景泰蓝，又称"铜胎掐丝珐琅"，是中国传统工艺美术的珍品，以其精湛的工艺、绚丽的色彩和独特的艺术风格，被誉为"东方艺术明珠"。',
                        lifeLesson: '传统工艺凝聚了古代匠人的智慧和创造力，保护这些技艺是我们的责任。'
                    },
                    {
                        content: '以下哪种传统工艺以"四大名绣"之一著称？',
                        options: ['苏绣', '湘绣', '粤绣', '蜀绣', '以上都是'],
                        correctIndex: 4,
                        explanation: '苏绣、湘绣、粤绣和蜀绣被称为中国"四大名绣"，各具特色，代表了中国传统刺绣工艺的最高水平。',
                        lifeLesson: '中国传统刺绣工艺历史悠久，技艺精湛，是中华文化的重要组成部分。'
                    },
                    {
                        content: '中国传统木雕工艺中，以下哪个地区以"东阳木雕"著称？',
                        options: ['浙江', '福建', '广东', '安徽'],
                        correctIndex: 0,
                        explanation: '东阳木雕是浙江东阳地区的传统木雕工艺，以其精湛的雕刻技艺和独特的艺术风格著称，被誉为"中国木雕之乡"。',
                        lifeLesson: '不同地区的传统工艺往往具有鲜明的地方特色，反映了当地的文化传统和审美观念。'
                    },
                    {
                        content: '以下哪种传统工艺与"文房四宝"有关？',
                        options: ['宣纸制作', '剪纸', '皮影戏', '糖画'],
                        correctIndex: 0,
                        explanation: '宣纸是中国传统的书写和绘画用纸，与笔、墨、砚并称为"文房四宝"。宣纸制作工艺是中国重要的非物质文化遗产。',
                        lifeLesson: '文房四宝是中国传统文人书房中必备的文具，也是中国传统文化的重要象征。'
                    },
                    {
                        content: '以下哪种传统工艺被称为"活的剪纸"？',
                        options: ['皮影戏', '风筝', '面塑', '蜡染'],
                        correctIndex: 0,
                        explanation: '皮影戏是一种以兽皮或纸板做成的人物剪影以表演故事的民间戏剧，其人物造型和表演方式类似于剪纸艺术，因此被称为"活的剪纸"。',
                        lifeLesson: '传统工艺之间往往相互影响、相互借鉴，共同构成了丰富多彩的中华文化。'
                    }
                ],
                successMessage: '恭喜你成为了一名优秀的传统技艺传承者！你已经深入了解了中国传统工艺的精湛技艺和文化内涵，这将帮助你更好地传承和保护这些宝贵的非物质文化遗产。'
            },
            {
                title: '传统戏曲鉴赏家',
                description: '中国传统戏曲是世界文化遗产的瑰宝，作为一名非遗守护人，你需要掌握传统戏曲的专业知识。',
                lifeGoal: '传承和弘扬传统戏曲文化，让古老的艺术形式在现代社会继续发扬光大。',
                questions: [
                    {
                        content: '中国传统戏曲中，京剧的"四大名旦"是指哪四位艺术家？',
                        options: ['梅兰芳、程砚秋、尚小云、荀慧生', '梅兰芳、周信芳、马连良、谭富英', '程砚秋、尚小云、荀慧生、张君秋', '梅兰芳、程砚秋、马连良、荀慧生'],
                        correctIndex: 0,
                        explanation: '京剧的"四大名旦"是指二十世纪二、三十年代活跃在中国京剧舞台上的四位杰出的旦角表演艺术家：梅兰芳、程砚秋、尚小云和荀慧生。',
                        lifeLesson: '传统戏曲是中华文化的瑰宝，了解其代表人物和艺术特色对于传承至关重要。'
                    },
                    {
                        content: '以下哪个剧种被称为"中国戏曲之母"？',
                        options: ['京剧', '昆曲', '豫剧', '粤剧'],
                        correctIndex: 1,
                        explanation: '昆曲是中国最古老的戏曲剧种之一，被誉为"中国戏曲之母"，对京剧等其他戏曲剧种的形成和发展产生了深远影响。',
                        lifeLesson: '昆曲是中国传统文化的重要组成部分，2001年被联合国教科文组织列为"人类口述和非物质遗产代表作"。'
                    },
                    {
                        content: '京剧的"生、旦、净、丑"分别指的是什么？',
                        options: ['角色行当', '表演技巧', '服装样式', '唱腔流派'],
                        correctIndex: 0,
                        explanation: '"生、旦、净、丑"是京剧的四大角色行当，分别代表不同类型的人物形象。生行是男性角色，旦行是女性角色，净行俗称花脸，丑行是喜剧角色。',
                        lifeLesson: '角色行当是传统戏曲的重要特征，不同的行当有其独特的表演程式和艺术风格。'
                    },
                    {
                        content: '以下哪个是豫剧的代表剧目？',
                        options: ['《霸王别姬》', '《花木兰》', '《天仙配》', '《白蛇传》'],
                        correctIndex: 1,
                        explanation: '《花木兰》是豫剧的经典剧目，讲述了花木兰代父从军的故事，由豫剧表演艺术家常香玉主演而闻名。',
                        lifeLesson: '不同的戏曲剧种往往有其代表性的剧目，这些剧目反映了当地的文化传统和审美观念。'
                    },
                    {
                        content: '传统戏曲中的"脸谱"主要用于哪个行当？',
                        options: ['生', '旦', '净', '丑'],
                        correctIndex: 2,
                        explanation: '脸谱是传统戏曲中净行（花脸）的重要特征，通过不同的色彩和图案来表现人物的性格和品质。',
                        lifeLesson: '脸谱艺术是中国传统戏曲的重要组成部分，具有独特的审美价值和文化内涵。'
                    }
                ],
                successMessage: '恭喜你成为了一名出色的传统戏曲鉴赏家！你已经掌握了中国传统戏曲的专业知识，这将帮助你更好地理解和传承这一宝贵的非物质文化遗产。'
            },
            {
                title: '非遗传承大师',
                description: '作为一名顶尖的非遗守护人，你需要全面掌握非物质文化遗产的保护和传承知识。',
                lifeGoal: '成为非物质文化遗产的守护者和传承者，让中华文化的瑰宝永远流传下去。',
                questions: [
                    {
                        content: '联合国教科文组织设立的"人类非物质文化遗产代表作名录"是从哪一年开始评选的？',
                        options: ['1999年', '2001年', '2003年', '2005年'],
                        correctIndex: 1,
                        explanation: '联合国教科文组织于2001年开始评选"人类非物质文化遗产代表作名录"，旨在保护和传承全球范围内的非物质文化遗产。',
                        lifeLesson: '非物质文化遗产的保护是全人类共同的责任，需要国际社会的共同努力。'
                    },
                    {
                        content: '以下哪项不属于非物质文化遗产的范畴？',
                        options: ['传统技艺', '民俗活动', '古建筑', '口头传说'],
                        correctIndex: 2,
                        explanation: '非物质文化遗产是指各种以非物质形态存在的与群众生活密切相关、世代相承的传统文化表现形式，包括口头传统、传统表演艺术、民俗活动和礼仪与节庆、有关自然界和宇宙的民间传统知识和实践、传统手工艺技能等。古建筑属于物质文化遗产。',
                        lifeLesson: '了解非物质文化遗产的定义和范畴，有助于我们更好地保护和传承这些宝贵的文化遗产。'
                    },
                    {
                        content: '中国第一个入选"人类非物质文化遗产代表作名录"的项目是什么？',
                        options: ['昆曲', '京剧', '古琴艺术', '端午节'],
                        correctIndex: 0,
                        explanation: '2001年，昆曲成为中国第一个入选"人类非物质文化遗产代表作名录"的项目，开启了中国非物质文化遗产保护的新篇章。',
                        lifeLesson: '昆曲作为中国最古老的戏曲剧种之一，具有极高的历史价值和艺术价值，是中华文化的重要象征。'
                    },
                    {
                        content: '以下哪种方法是保护非物质文化遗产的有效途径？',
                        options: ['记录和保存', '商业化开发', '现代化改造', '以上都是'],
                        correctIndex: 0,
                        explanation: '记录和保存是非物质文化遗产保护的基础，通过文字、录音、录像等方式将非物质文化遗产记录下来，为后人留下宝贵的资料。商业化开发和现代化改造需要谨慎进行，避免对非物质文化遗产的本质造成破坏。',
                        lifeLesson: '非物质文化遗产的保护需要采取科学合理的方法，在保护其本质特征的前提下，探索其在现代社会中的传承和发展。'
                    },
                    {
                        content: '作为一名非遗守护人，以下哪种态度是正确的？',
                        options: ['认为传统的就是过时的，应该被淘汰', '认为传统的都是最好的，必须原封不动地保留', '尊重传统，同时探索传统在现代社会中的创新发展', '对传统不感兴趣，专注于现代文化'],
                        correctIndex: 2,
                        explanation: '正确的态度应该是尊重传统，认识到非物质文化遗产的价值，同时也要看到传统需要在现代社会中找到新的生存和发展空间，通过创新来延续其生命力。',
                        lifeLesson: '非物质文化遗产的保护不是简单的保存，而是在传承中创新，在创新中传承，让古老的文化在现代社会中焕发新的生机。'
                    }
                ],
                successMessage: '恭喜你成为了一名真正的非遗传承大师！你已经完成了所有的非物质文化遗产知识考验，展现了对中华文化的深刻理解和保护传承的决心。现在，你准备好肩负起传承和保护中华文化瑰宝的重任了吗？'
            }
        ],
        achievements: {
            level1: {
                name: '文化启蒙者',
                description: '成功完成了文化启蒙者关卡，初步掌握了中国传统文化的基础知识。',
                icon: '📚'
            },
            level2: {
                name: '节日守护者',
                description: '深入了解了中国传统节日的文化内涵，成为了一名合格的节日守护者。',
                icon: '🎎'
            },
            final: {
                name: '非遗传承大师',
                description: '成功通过了所有传统文化知识的考验，成为了一名真正的非遗传承大师！',
                icon: '🏮'
            }
        }
    },
    
    // 星球开拓者角色
    space: {
        name: '星球开拓者',
        tagline: '探索宇宙奥秘的先锋',
        description: '你将成为一名勇敢的星际开拓者，探索遥远的星球和宇宙奥秘，通过解决各种科学问题来完成你的星际探索任务。',
        story: [
            {
                text: '作为一名年轻的星球开拓者，你被选中参加一项激动人心的星际探索任务。你的目标是探索一个未知的星系，寻找适合人类居住的新家园，并收集关于宇宙的宝贵数据。',
                next: true
            },
            {
                text: '在这次探索任务中，你将面临各种科学挑战和宇宙谜题。每解决一个问题，你就能更深入地了解宇宙的奥秘，为人类的星际移民计划做出贡献。',
                next: true
            },
            {
                text: '现在，准备好接受第一个宇宙知识的挑战了吗？这将是你成为传奇星球开拓者的第一步！',
                next: true,
                startBattle: true
            }
        ],
        levels: [
            {
                title: '太阳系探索者',
                description: '作为一名新手星球开拓者，你需要先了解我们所在的太阳系的基础知识。',
                lifeGoal: '探索宇宙的旅程，从了解我们的太阳系开始。',
                questions: [
                    {
                        content: '在太阳系中，哪个行星被称为"红色星球"？',
                        options: ['金星', '火星', '木星', '土星'],
                        correctIndex: 1,
                        explanation: '火星被称为"红色星球"，这是因为火星表面富含氧化铁（铁锈），使得它呈现出独特的红色外观。',
                        lifeLesson: '了解太阳系中的行星特征是成为优秀星际探索者的第一步。'
                    },
                    {
                        content: '太阳系中最大的行星是哪一个？',
                        options: ['地球', '土星', '木星', '天王星'],
                        correctIndex: 2,
                        explanation: '木星是太阳系中最大的行星，其直径约为地球的11倍，质量约为其他所有行星质量总和的2.5倍。',
                        lifeLesson: '太阳系中的行星各具特色，了解它们的大小和结构有助于我们更好地理解宇宙。'
                    },
                    {
                        content: '地球的卫星是什么？',
                        options: ['金星', '火星', '月球', '木星'],
                        correctIndex: 2,
                        explanation: '月球是地球唯一的天然卫星，它围绕地球运行，对地球的潮汐现象产生重要影响。',
                        lifeLesson: '卫星是行星的重要组成部分，研究卫星可以帮助我们更好地了解行星的形成和演化。'
                    },
                    {
                        content: '太阳系中哪颗行星被称为"地球的孪生姐妹"？',
                        options: ['金星', '火星', '土星', '木星'],
                        correctIndex: 0,
                        explanation: '金星被称为"地球的孪生姐妹"，因为它的大小、质量和密度都与地球相似，但表面环境却极为恶劣。',
                        lifeLesson: '即使看起来相似的天体，其内部结构和表面环境也可能有很大的差异。'
                    },
                    {
                        content: '太阳系中距离太阳最远的行星是哪一颗？',
                        options: ['土星', '天王星', '海王星', '冥王星'],
                        correctIndex: 2,
                        explanation: '海王星是太阳系中距离太阳最远的行星，冥王星在2006年被重新分类为矮行星。',
                        lifeLesson: '我们对太阳系的认识是不断发展和完善的，科学探索永无止境。'
                    }
                ],
                successMessage: '恭喜你完成了太阳系探索者关卡！你已经掌握了太阳系的基础知识，这将帮助你在未来的星际探索中更好地理解宇宙的奥秘。'
            },
            {
                title: '宇宙测量师',
                description: '要成为一名出色的星球开拓者，你需要掌握宇宙测量的基本单位和方法。',
                lifeGoal: '准确测量宇宙中的距离和时间，是探索宇宙的基础技能。',
                questions: [
                    {
                        content: '光年是什么单位？',
                        options: ['时间单位', '距离单位', '速度单位', '质量单位'],
                        correctIndex: 1,
                        explanation: '光年是一个距离单位，指的是光在真空中一年内传播的距离，约为9.46万亿公里。',
                        lifeLesson: '在宇宙尺度上，我们需要特殊的单位来测量巨大的距离。'
                    },
                    {
                        content: '以下哪种天体被称为"宇宙中的灯塔"，可以帮助天文学家测量宇宙距离？',
                        options: ['恒星', '行星', '超新星', '造父变星'],
                        correctIndex: 3,
                        explanation: '造父变星是一种特殊的变星，其亮度变化周期与其真实亮度之间存在确定的关系。天文学家可以利用这一关系来测量造父变星的距离，因此它们被称为"宇宙中的灯塔"。',
                        lifeLesson: '天文学家使用各种巧妙的方法来测量宇宙中的距离，造父变星是其中重要的工具之一。'
                    },
                    {
                        content: '银河系的直径大约是多少光年？',
                        options: ['10,000光年', '100,000光年', '1,000,000光年', '10,000,000光年'],
                        correctIndex: 1,
                        explanation: '银河系的直径大约为10万光年，这意味着光从银河系的一端传播到另一端需要大约10万年的时间。',
                        lifeLesson: '宇宙的尺度远远超出我们的日常经验，需要我们用新的思维方式来理解。'
                    },
                    {
                        content: '地球到太阳的平均距离被称为什么单位？',
                        options: ['天文单位', '光年', '秒差距', '公里'],
                        correctIndex: 0,
                        explanation: '地球到太阳的平均距离被称为一个天文单位（AU），约等于1.5亿公里，是天文学中常用的距离单位。',
                        lifeLesson: '在不同的尺度上，我们需要使用不同的测量单位来方便地描述距离。'
                    },
                    {
                        content: '哈勃定律告诉我们什么？',
                        options: ['宇宙在膨胀', '宇宙在收缩', '宇宙是静止的', '宇宙是无限的'],
                        correctIndex: 0,
                        explanation: '哈勃定律表明，星系离我们越远，其远离我们的速度就越快，这是宇宙膨胀的重要证据。',
                        lifeLesson: '现代天文学的发现不断刷新我们对宇宙的认识，推动着科学的进步。'
                    }
                ],
                successMessage: '太棒了！你已经成为了一名合格的宇宙测量师。掌握宇宙测量的方法将帮助你在星际探索中准确定位和导航。'
            },
            {
                title: '黑洞探险家',
                description: '作为一名成熟的星球开拓者，你需要探索宇宙中最神秘的天体——黑洞。',
                lifeGoal: '探索宇宙中最极端的物理现象，是勇敢的星球开拓者的终极挑战。',
                questions: [
                    {
                        content: '黑洞的逃逸速度大于什么？',
                        options: ['地球的逃逸速度', '太阳的逃逸速度', '光速', '声速'],
                        correctIndex: 2,
                        explanation: '黑洞的引力非常强大，以至于其逃逸速度大于光速。这意味着连光都无法从黑洞中逃逸出来，因此黑洞是"黑"的。',
                        lifeLesson: '黑洞是宇宙中最极端的天体之一，挑战着我们对物理规律的理解。'
                    },
                    {
                        content: '黑洞的边界被称为什么？',
                        options: ['事件视界', '奇点', '视界边缘', '黑洞表面'],
                        correctIndex: 0,
                        explanation: '事件视界是黑洞的边界，一旦物体越过事件视界，就再也无法逃脱黑洞的引力，包括光在内。',
                        lifeLesson: '事件视界是黑洞最显著的特征之一，它标志着我们对黑洞内部了解的极限。'
                    },
                    {
                        content: '根据爱因斯坦的广义相对论，黑洞是如何形成的？',
                        options: ['恒星死亡后坍缩形成', '宇宙大爆炸时直接形成', '暗物质聚集形成', '外星文明创造'],
                        correctIndex: 0,
                        explanation: '当质量足够大的恒星耗尽核燃料后，会发生引力坍缩，最终形成黑洞。',
                        lifeLesson: '黑洞的形成是恒星演化的最终阶段之一，体现了宇宙中物质和能量的转化过程。'
                    },
                    {
                        content: '黑洞会"蒸发"吗？',
                        options: ['不会，黑洞只会不断吞噬物质', '会，通过霍金辐射', '不确定', '只有小黑洞会蒸发'],
                        correctIndex: 1,
                        explanation: '根据霍金辐射理论，黑洞会通过量子效应向外辐射粒子，最终导致黑洞"蒸发"，不过这一过程极其缓慢。',
                        lifeLesson: '黑洞并不是完全"黑"的，它也会与周围环境发生相互作用。'
                    },
                    {
                        content: '银河系中心是否存在超大质量黑洞？',
                        options: ['是', '否', '不确定', '可能存在但未被证实'],
                        correctIndex: 0,
                        explanation: '科学家通过观测银河系中心恒星的运动轨迹，已经证实银河系中心存在一个质量约为400万个太阳质量的超大质量黑洞，被称为人马座A*。',
                        lifeLesson: '超大质量黑洞可能存在于大多数星系的中心，对星系的形成和演化产生重要影响。'
                    }
                ],
                successMessage: '恭喜你成为了一名真正的黑洞探险家！你已经掌握了黑洞的基本知识，这将帮助你在星际探索中应对宇宙中最极端的物理现象。'
            },
            {
                title: '星际农业专家',
                description: '作为一名资深的星球开拓者，你需要探索在太空和其他星球上进行农业生产的可能性。',
                lifeGoal: '解决人类星际移民中的食物问题，是实现长期太空探索的关键。',
                questions: [
                    {
                        content: '在太空中种植植物面临的最大挑战是什么？',
                        options: ['重力缺失', '辐射', '温度控制', '所有以上因素'],
                        correctIndex: 3,
                        explanation: '在太空中种植植物需要解决重力缺失、宇宙辐射、温度控制、光照、空气和水等多个方面的问题，是一项复杂的系统工程。',
                        lifeLesson: '在极端环境中生存和发展，需要我们创造性地解决各种问题。'
                    },
                    {
                        content: '以下哪种植物最适合在太空环境中种植？',
                        options: ['水稻', '小麦', '生菜', '玉米'],
                        correctIndex: 2,
                        explanation: '生菜等叶菜类植物生长周期短、占用空间小、营养价值高，相对更容易在太空环境中种植，已经在国际空间站上成功种植。',
                        lifeLesson: '选择适合的作物是太空农业成功的关键之一。'
                    },
                    {
                        content: '太空种植中，植物的根通常向哪个方向生长？',
                        options: ['向下', '向上', '随机方向', '向营养物质方向'],
                        correctIndex: 3,
                        explanation: '在失重环境中，植物的根不再受到重力的引导，而是会向营养物质和水分丰富的方向生长，这种现象被称为向化性。',
                        lifeLesson: '生物会通过各种方式适应环境的变化，展现出惊人的生命力和适应性。'
                    },
                    {
                        content: '在火星上种植植物，需要解决的首要问题是什么？',
                        options: ['火星土壤毒性', '极端温度', '低气压', '辐射'],
                        correctIndex: 0,
                        explanation: '火星土壤中含有高浓度的有毒物质，如高氯酸盐，对植物生长极为不利，需要进行处理或使用人工土壤。',
                        lifeLesson: '在进行外星殖民前，我们需要充分了解目标星球的环境特点，并找到相应的解决方案。'
                    },
                    {
                        content: '太空农业的主要目的是什么？',
                        options: ['提供食物', '提供氧气', '循环利用废物', '所有以上目的'],
                        correctIndex: 3,
                        explanation: '太空农业不仅可以为宇航员提供新鲜食物，还可以通过光合作用产生氧气，同时通过植物吸收和微生物分解来循环利用废物，是太空生态系统的重要组成部分。',
                        lifeLesson: '建立封闭的生态循环系统是实现长期太空探索和外星殖民的基础。'
                    }
                ],
                successMessage: '恭喜你成为了一名出色的星际农业专家！你已经掌握了在太空和其他星球上进行农业生产的关键知识，这将为人类的星际移民计划奠定重要基础。'
            },
            {
                title: '外星资源勘探者',
                description: '作为一名顶级的星球开拓者，你需要学习如何勘探和利用外星资源，为人类的星际殖民提供物质基础。',
                lifeGoal: '发现和利用外星资源，是实现可持续星际探索的重要保障。',
                questions: [
                    {
                        content: '月球上最有价值的资源是什么？',
                        options: ['水冰', '矿产资源', '太阳能', '所有以上资源'],
                        correctIndex: 3,
                        explanation: '月球上的水冰可以分解为氢气和氧气，用于呼吸和火箭燃料；矿产资源如氦-3是潜在的核聚变燃料；月球表面的太阳能资源也非常丰富。',
                        lifeLesson: '不同的外星环境蕴含着不同的资源，需要我们有针对性地进行勘探和开发。'
                    },
                    {
                        content: '小行星带中最常见的资源是什么？',
                        options: ['金属矿产', '水', '有机物质', '稀有气体'],
                        correctIndex: 0,
                        explanation: '小行星带中的小行星主要由岩石和金属组成，富含铁、镍、铂等金属矿产，是未来太空采矿的重要目标。',
                        lifeLesson: '小行星带是太阳系中重要的资源宝库，开发小行星资源将为人类的太空探索提供物质支持。'
                    },
                    {
                        content: '在火星上，水主要以什么形式存在？',
                        options: ['液态水', '水蒸气', '冰', '矿物结合水'],
                        correctIndex: 2,
                        explanation: '由于火星表面温度低、气压低，水无法以液态形式长期存在，主要以冰的形式存在于两极和地下。',
                        lifeLesson: '了解目标星球上水资源的分布和存在形式，对于实现外星殖民至关重要。'
                    },
                    {
                        content: '太空采矿面临的主要技术挑战是什么？',
                        options: ['低重力环境作业', '远程操作', '资源运输', '所有以上挑战'],
                        correctIndex: 3,
                        explanation: '太空采矿需要解决低重力环境下的作业、远程控制和自动化、资源的加工和运输等多个技术难题，是一项复杂的系统工程。',
                        lifeLesson: '技术创新是推动太空探索和资源开发的核心动力。'
                    },
                    {
                        content: '开发外星资源对人类有什么重要意义？',
                        options: ['减轻地球资源压力', '支持太空探索和殖民', '促进科技发展', '所有以上意义'],
                        correctIndex: 3,
                        explanation: '开发外星资源不仅可以减轻地球的资源压力，还可以为太空探索和殖民提供物质支持，同时促进相关技术的发展和创新。',
                        lifeLesson: '探索和开发宇宙资源是人类文明可持续发展的重要方向。'
                    }
                ],
                successMessage: '恭喜你成为了一名卓越的外星资源勘探者！你已经掌握了勘探和利用外星资源的专业知识，这将为人类的星际探索和殖民计划提供重要的物质保障。现在，你准备好带领人类开启宇宙资源开发的新篇章了吗？'
            }
        ],
        achievements: {
            level1: {
                name: '太阳系探索者',
                description: '成功完成了太阳系探索者关卡，初步掌握了太阳系的基础知识。',
                icon: '🪐'
            },
            level2: {
                name: '宇宙测量师',
                description: '掌握了宇宙测量的基本单位和方法，成为了一名合格的宇宙测量师。',
                icon: '📏'
            },
            final: {
                name: '星际探索大师',
                description: '成功完成了所有宇宙知识的挑战，成为了一名真正的星际探索大师！',
                icon: '🚀'
            }
        }
    },
    
    // 数学探索家角色
    math: {
        name: '数学探索家',
        tagline: '用数学思维探索世界的奥秘',
        description: '你将成为一名热爱数学的探索家，通过解决各种数学问题，揭示隐藏在数字背后的规律和美丽。',
        story: [
            {
                text: '作为一名年轻的数学探索家，你对数字世界充满了好奇。今天，你发现了一本古老的数学手稿，上面记载着一系列富有挑战性的数学问题，这些问题据说能够帮助人们更好地理解数学的本质。',
                next: true
            },
            {
                text: '为了解开这些数学谜题，你需要运用你的数学知识和思维能力。每解决一个问题，你就能更深入地理解数学的奥秘，发现数字世界的美丽和规律。',
                next: true
            },
            {
                text: '现在，准备好接受第一个数学挑战了吗？这将是你成为杰出数学探索家的第一步！',
                next: true,
                startBattle: true
            }
        ],
        levels: [
            {
                title: '数列探索者',
                description: '作为一名数学探索家，你需要先掌握数列的基本规律，这是理解数学世界的重要基础。',
                lifeGoal: '发现数字背后的规律，是开启数学探索之旅的钥匙。',
                questions: [
                    {
                        content: '在数学中，斐波那契数列的前两项是0和1，之后的每一项都是前两项之和。请问斐波那契数列的第10项是多少？',
                        options: ['21', '34', '55', '89'],
                        correctIndex: 1,
                        explanation: '斐波那契数列前10项依次是：0, 1, 1, 2, 3, 5, 8, 13, 21, 34。所以第10项是34。',
                        lifeLesson: '数列规律在自然界和生活中无处不在，掌握它们能帮助我们更好地理解世界的运行方式。'
                    },
                    {
                        content: '以下哪个数学常数的值约为3.14159？',
                        options: ['e', 'φ', 'π', 'γ'],
                        correctIndex: 2,
                        explanation: 'π（圆周率）是一个数学常数，表示圆的周长与直径的比值，其近似值为3.14159。',
                        lifeLesson: '数学常数是数学世界的基石，它们连接着不同的数学领域，展现了数学的统一之美。'
                    },
                    {
                        content: '等差数列1, 4, 7, 10, ...的第20项是多少？',
                        options: ['55', '58', '61', '64'],
                        correctIndex: 2,
                        explanation: '等差数列的通项公式为a_n = a_1 + (n-1)d，其中a_1=1，d=3，所以第20项为1 + (20-1)*3 = 1 + 57 = 58。',
                        lifeLesson: '等差数列是数学中最基本的数列类型之一，掌握其规律有助于解决许多实际问题。'
                    },
                    {
                        content: '等比数列2, 4, 8, 16, ...的公比是多少？',
                        options: ['1', '2', '3', '4'],
                        correctIndex: 1,
                        explanation: '等比数列中，后一项与前一项的比值称为公比。在这个数列中，4/2=2，8/4=2，16/8=2，所以公比是2。',
                        lifeLesson: '等比数列在增长问题中有着广泛的应用，理解其增长模式对分析许多自然和社会现象很有帮助。'
                    },
                    {
                        content: '以下哪个数列是质数数列？',
                        options: ['1, 2, 3, 5, 7', '2, 3, 5, 7, 11', '3, 5, 7, 9, 11', '2, 4, 6, 8, 10'],
                        correctIndex: 1,
                        explanation: '质数是指大于1的自然数，除了1和它本身外，不能被其他自然数整除的数。选项B中的2, 3, 5, 7, 11都是质数，而选项A中的1不是质数，选项C中的9不是质数，选项D中的数都是偶数（除了2）。',
                        lifeLesson: '质数是数学中的基础概念，在数论和密码学等领域有着重要的应用。'
                    }
                ],
                successMessage: '恭喜你完成了数列探索者关卡！你已经掌握了数列的基本规律，这将帮助你在数学探索的道路上发现更多数字的奥秘。'
            },
            {
                title: '几何发现者',
                description: '数学不仅仅是数字，几何图形也蕴含着丰富的数学规律。作为一名数学探索家，你需要理解几何图形的基本性质。',
                lifeGoal: '培养几何直观能力，发现空间与形状的数学规律。',
                questions: [
                    {
                        content: '一个三角形的三个内角之和是多少度？',
                        options: ['90°', '180°', '270°', '360°'],
                        correctIndex: 1,
                        explanation: '在欧几里得几何中，任意三角形的三个内角之和恒等于180度，这是三角形的基本性质之一。',
                        lifeLesson: '几何定理是人类对空间规律的总结，它们帮助我们理解和描述我们周围的世界。'
                    },
                    {
                        content: '正方形的周长为20厘米，它的面积是多少平方厘米？',
                        options: ['20', '25', '40', '50'],
                        correctIndex: 1,
                        explanation: '正方形的周长=4×边长，所以边长=20÷4=5厘米。正方形的面积=边长×边长=5×5=25平方厘米。',
                        lifeLesson: '掌握基本几何图形的周长和面积公式，是解决几何问题的基础。'
                    },
                    {
                        content: '圆的半径为5厘米，它的面积是多少平方厘米？（π取3.14）',
                        options: ['15.7', '31.4', '78.5', '157'],
                        correctIndex: 2,
                        explanation: '圆的面积公式为S=πr²，其中r为半径。所以面积=3.14×5²=3.14×25=78.5平方厘米。',
                        lifeLesson: '圆是自然界中最完美的图形之一，其面积和周长公式在许多领域都有广泛应用。'
                    },
                    {
                        content: '以下哪种图形是正多边形？',
                        options: ['正方形', '长方形', '平行四边形', '梯形'],
                        correctIndex: 0,
                        explanation: '正多边形是指所有边长都相等且所有内角都相等的多边形。正方形的四条边都相等，四个角都是90度，所以是正多边形。而长方形、平行四边形和梯形不满足所有边长相等和所有内角相等的条件。',
                        lifeLesson: '正多边形具有高度的对称性，在艺术、建筑和设计中有着广泛的应用。'
                    },
                    {
                        content: '正方体有多少个面？多少条棱？多少个顶点？',
                        options: ['4个面，6条棱，4个顶点', '6个面，8条棱，8个顶点', '6个面，12条棱，8个顶点', '8个面，12条棱，6个顶点'],
                        correctIndex: 2,
                        explanation: '正方体是一种正多面体，它有6个面（每个面都是正方形），12条棱（每条棱长度相等），8个顶点（每个顶点连接3条棱）。',
                        lifeLesson: '了解三维几何体的基本结构，有助于培养空间想象能力和解决立体几何问题的能力。'
                    }
                ],
                successMessage: '太棒了！你已经成为了一名出色的几何发现者。掌握几何图形的性质将帮助你在数学探索中发现更多的规律和美感。'
            },
            {
                title: '代数推理师',
                description: '代数是数学的重要分支，作为一名成熟的数学探索家，你需要运用代数思维来解决更复杂的数学问题。',
                lifeGoal: '培养代数思维和逻辑推理能力，是成为优秀数学探索家的关键。',
                questions: [
                    {
                        content: '解方程：2x + 5 = 17',
                        options: ['x = 6', 'x = 8', 'x = 11', 'x = 12'],
                        correctIndex: 0,
                        explanation: '解方程2x + 5 = 17，首先将5移到等号右边得到2x = 17 - 5 = 12，然后两边同时除以2，得到x = 6。',
                        lifeLesson: '代数方程是解决实际问题的有力工具，通过建立方程，我们可以将复杂问题转化为可求解的数学形式。'
                    },
                    {
                        content: '在统计学中，一组数据的平均数、中位数和众数，哪个是出现次数最多的数值？',
                        options: ['平均数', '中位数', '众数', '以上都不是'],
                        correctIndex: 2,
                        explanation: '众数是一组数据中出现次数最多的数值。平均数是所有数据的总和除以数据个数，中位数是将数据按大小顺序排列后位于中间位置的数值。',
                        lifeLesson: '统计学是认识和理解数据的科学，掌握基本的统计概念有助于我们从数据中提取有价值的信息。'
                    },
                    {
                        content: '以下哪个表达式与2x + 3y + 4x - y等价？',
                        options: ['6x + 2y', '5x + 3y', '6x + 4y', '2x + 4y'],
                        correctIndex: 0,
                        explanation: '将同类项合并，2x + 4x = 6x，3y - y = 2y，所以等价于6x + 2y。',
                        lifeLesson: '合并同类项是代数运算的基本技能，它可以帮助我们简化复杂的数学表达式。'
                    },
                    {
                        content: '如果a = 3，b = 4，那么a² + b²等于多少？',
                        options: ['12', '14', '25', '49'],
                        correctIndex: 2,
                        explanation: 'a² = 3² = 9，b² = 4² = 16，所以a² + b² = 9 + 16 = 25。',
                        lifeLesson: '平方和在几何和物理中有着广泛的应用，例如勾股定理就是一种特殊的平方和关系。'
                    },
                    {
                        content: '不等式2x - 3 > 5的解集是什么？',
                        options: ['x > 1', 'x > 4', 'x < 1', 'x < 4'],
                        correctIndex: 1,
                        explanation: '解不等式2x - 3 > 5，首先将-3移到右边得到2x > 5 + 3 = 8，然后两边同时除以2，得到x > 4。',
                        lifeLesson: '不等式在表示范围和限制条件时非常有用，掌握不等式的解法对于解决实际问题很重要。'
                    }
                ],
                successMessage: '恭喜你成为了一名合格的代数推理师！你已经掌握了代数的基本概念和方法，这将帮助你解决更复杂的数学问题。'
            },
            {
                title: '概率统计学家',
                description: '概率和统计是数学中与现实世界联系最紧密的分支之一。作为一名数学探索家，你需要理解随机现象和数据背后的规律。',
                lifeGoal: '培养数据分析能力和概率思维，是理解不确定性世界的关键。',
                questions: [
                    {
                        content: '抛一枚均匀的硬币，正面朝上的概率是多少？',
                        options: ['0', '1/4', '1/2', '1'],
                        correctIndex: 2,
                        explanation: '抛一枚均匀的硬币，有两种可能的结果：正面朝上和反面朝上，且每种结果出现的可能性相等，所以正面朝上的概率是1/2。',
                        lifeLesson: '概率是衡量随机事件发生可能性大小的量，掌握概率的基本概念有助于我们理性地分析和决策。'
                    },
                    {
                        content: '从一副标准的52张扑克牌中随机抽取一张，抽到黑桃的概率是多少？',
                        options: ['1/52', '1/13', '1/4', '1/2'],
                        correctIndex: 2,
                        explanation: '一副标准的扑克牌有4种花色，每种花色有13张牌，所以黑桃有13张。抽到黑桃的概率是13/52 = 1/4。',
                        lifeLesson: '古典概型是概率计算的基础，它适用于所有可能结果有限且等可能的情况。'
                    },
                    {
                        content: '一组数据：5, 7, 8, 9, 10，它们的中位数是多少？',
                        options: ['7', '8', '9', '10'],
                        correctIndex: 1,
                        explanation: '中位数是将数据按大小顺序排列后位于中间位置的数值。这组数据已经按顺序排列，中间的数是8，所以中位数是8。',
                        lifeLesson: '中位数是一种位置平均数，它不受极端值的影响，在描述数据集中趋势时很有用。'
                    },
                    {
                        content: '以下哪种统计量可以反映一组数据的离散程度？',
                        options: ['平均数', '中位数', '众数', '标准差'],
                        correctIndex: 3,
                        explanation: '标准差是衡量数据离散程度的重要统计量，它反映了数据相对于平均数的分散程度。标准差越大，数据的离散程度越大；标准差越小，数据的离散程度越小。',
                        lifeLesson: '了解数据的离散程度，有助于我们更全面地理解数据的分布特征。'
                    },
                    {
                        content: '在概率中，"不可能事件"的概率是多少？"必然事件"的概率是多少？',
                        options: ['0和1', '1和0', '0和0', '1和1'],
                        correctIndex: 0,
                        explanation: '不可能事件是指一定不会发生的事件，其概率为0；必然事件是指一定会发生的事件，其概率为1。',
                        lifeLesson: '概率的取值范围是从0到1，0表示不可能发生，1表示必然发生。'
                    }
                ],
                successMessage: '恭喜你成为了一名出色的概率统计学家！你已经掌握了概率和统计的基本概念和方法，这将帮助你更好地理解和分析现实世界中的随机现象和数据。'
            },
            {
                title: '应用数学家',
                description: '数学不仅是抽象的科学，也是解决实际问题的有力工具。作为一名顶级的数学探索家，你需要将数学知识应用到实际问题中。',
                lifeGoal: '将数学理论与实际应用相结合，用数学思维解决现实问题。',
                questions: [
                    {
                        content: '小明从家到学校的距离是2公里，他步行的速度是每分钟80米，他需要多少分钟才能到达学校？',
                        options: ['15', '20', '25', '30'],
                        correctIndex: 2,
                        explanation: '首先将距离单位统一，2公里=2000米。时间=距离÷速度=2000÷80=25分钟。',
                        lifeLesson: '数学在解决日常生活中的问题时非常有用，掌握基本的数学运算和单位换算技能很重要。'
                    },
                    {
                        content: '一家商店将一件商品的价格从100元提高到120元，提价的百分比是多少？',
                        options: ['10%', '15%', '20%', '25%'],
                        correctIndex: 2,
                        explanation: '提价的金额是120-100=20元。提价的百分比=（提价金额÷原价）×100%=（20÷100）×100%=20%。',
                        lifeLesson: '百分比计算在商业和经济活动中有着广泛的应用，掌握百分比的计算方法有助于我们理解各种经济现象。'
                    },
                    {
                        content: '一个圆柱形水桶的底面半径是30厘米，高是50厘米，它的容积是多少升？（π取3.14，1升=1000立方厘米）',
                        options: ['141.3', '471', '1413', '4710'],
                        correctIndex: 0,
                        explanation: '圆柱的体积公式为V=πr²h，所以水桶的容积=3.14×30²×50=3.14×900×50=141300立方厘米=141.3升。',
                        lifeLesson: '几何知识在计算容器容积、物体体积等实际问题中有着重要的应用。'
                    },
                    {
                        content: '某公司去年的利润是100万元，今年的利润比去年增长了20%，今年的利润是多少万元？',
                        options: ['80', '100', '120', '140'],
                        correctIndex: 2,
                        explanation: '今年的利润=去年的利润×（1+增长率）=100×（1+20%）=100×1.2=120万元。',
                        lifeLesson: '增长率问题在经济分析、人口预测等领域有着广泛的应用，理解增长率的计算方法很重要。'
                    },
                    {
                        content: '在比例尺为1:100000的地图上，量得两地之间的距离是5厘米，那么两地之间的实际距离是多少公里？',
                        options: ['0.5', '5', '50', '500'],
                        correctIndex: 1,
                        explanation: '比例尺1:100000表示地图上的1厘米代表实际距离的100000厘米。所以实际距离=5×100000=500000厘米=5公里。',
                        lifeLesson: '比例尺在地图、工程图纸等领域有着广泛的应用，掌握比例尺的计算方法有助于我们准确理解和使用各种图纸。'
                    }
                ],
                successMessage: '恭喜你成为了一名卓越的应用数学家！你已经成功地将数学知识应用到了各种实际问题中，展现了数学的实用性和魅力。数学是打开科学之门的钥匙，继续你的数学探索之旅吧！'
            }
        ],
        achievements: {
            level1: {
                name: '数列探索者',
                description: '成功完成了数列探索者关卡，掌握了数列的基本规律。',
                icon: '🔢'
            },
            level2: {
                name: '几何发现者',
                description: '掌握了几何图形的基本性质，成为了一名出色的几何发现者。',
                icon: '📐'
            },
            final: {
                name: '数学探索大师',
                description: '成功完成了所有数学问题的挑战，成为了一名真正的数学探索大师！',
                icon: '⭐'
            }
        }
    }
};



// 更新所有角色的进度显示
function updateAllCharacterProgress() {
    // 更新四个角色的进度
    updateCharacterProgress('cyber');
    updateCharacterProgress('heritage');
    updateCharacterProgress('space');
    updateCharacterProgress('math');
}

// 更新单个角色的进度显示
function updateCharacterProgress(characterId) {
    const completedLevels = getCompletedLevels(characterId);
    const totalLevels = characterTotalLevels[characterId];
    const progressPercentage = (completedLevels / totalLevels) * 100;
    
    // 更新进度条宽度
    const progressFill = elements[`${characterId}ProgressFill`];
    const progressInfo = elements[`${characterId}ProgressInfo`];
    
    if (progressFill && progressInfo) {
        progressFill.style.width = `${progressPercentage}%`;
        progressInfo.textContent = `${completedLevels}/${totalLevels}`;
    }
}

// 获取指定角色已完成的关卡数
function getCompletedLevels(characterId) {
    // 添加错误检查，确保characters对象存在
    if (typeof characters === 'undefined') {
        console.error('characters对象未定义');
        return 0;
    }
    
    if (typeof characterId !== 'string') {
        console.error('characterId必须是字符串类型');
        return 0;
    }
    
    // 从本地存储加载成就信息
    let achievements = [];
    try {
        achievements = JSON.parse(localStorage.getItem('achievements') || '[]');
    } catch (error) {
        console.error('加载成就失败:', error);
    }
    
    // 从analytics中获取关卡完成信息
    const completedLevel = appState?.analytics?.levelCompletions?.[characterId] || 0;
    
    // 获取角色的成就定义，增加额外的错误检查
    const characterAchievements = (characters && characters[characterId] && characters[characterId].achievements) || {};
    
    // 计算已完成的关卡数
    let count = 0;
    
    // 检查characterTotalLevels是否存在
    if (typeof characterTotalLevels !== 'undefined' && characterTotalLevels[characterId]) {
        // 检查每个关卡成就是否已完成
        for (let i = 1; i <= characterTotalLevels[characterId]; i++) {
            const levelKey = `level${i}`;
            const levelAchievement = characterAchievements[levelKey];
            
            if (levelAchievement && achievements.includes(levelAchievement.name)) {
                count++;
            }
        }
    } else {
        console.warn(`未找到角色${characterId}的总关卡数定义`);
    }
    
    // 返回较大的值，确保进度条不会回退
    return Math.max(count, completedLevel);
}

// 音效管理器
const soundEffects = {
    // 音频上下文（懒加载）
    _audioContext: null,
    
    // 获取或创建音频上下文
    _getAudioContext() {
        if (!this._audioContext) {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            try {
                this._audioContext = new AudioContext();
            } catch (e) {
                console.error('创建AudioContext失败:', e);
            }
        }
        
        // 确保音频上下文处于运行状态
        if (this._audioContext && this._audioContext.state === 'suspended') {
            this._audioContext.resume().catch(e => {
                console.error('恢复AudioContext失败:', e);
            });
        }
        
        return this._audioContext;
    },
    
    // 播放角色选择音效
    playCharacterSelect(characterId) {
        // 使用Web Audio API播放简单的声音
        this._playSimpleSound(440, 0.1); // 440Hz，持续0.1秒
        console.log(`播放角色选择音效: ${characterId}`);
    },
    
    // 播放故事进度音效
    playStoryProgress() {
        // 使用Web Audio API播放简单的声音序列
        this._playSimpleSound(330, 0.1); // 330Hz
        setTimeout(() => this._playSimpleSound(440, 0.1), 100); // 延迟100ms播放440Hz
        console.log('播放故事进度音效');
    },
    
    // 播放成功音效
    playSuccess() {
        // 使用Web Audio API播放简单的成功音效
        this._playSimpleSound(523.25, 0.1); // C5
        setTimeout(() => this._playSimpleSound(659.25, 0.1), 100); // E5
        setTimeout(() => this._playSimpleSound(783.99, 0.2), 200); // G5
        console.log('播放成功音效');
    },
    
    // 播放反馈语音 - 使用Web Audio API修复版
    playFeedbackVoice(style) {
        console.log(`尝试播放${style}风格的语音反馈（Web Audio API修复版）`);
        
        try {
            const audioContext = this._getAudioContext();
            if (!audioContext) {
                console.error('AudioContext不可用，无法播放声音');
                return;
            }
            
            // 根据风格选择不同的音高
            let frequency = 440; // 默认A4
            switch (style) {
                case 'happy':
                    frequency = 523.25; // C5
                    break;
                case 'encouraging':
                    frequency = 493.88; // B4
                    break;
                case 'surprised':
                    frequency = 587.33; // D5
                    break;
                default:
                    frequency = 440; // A4
            }
            
            // 播放反馈声音
            this._playSimpleSound(frequency, 0.5);
            console.log(`成功播放${style}风格的语音反馈（Web Audio API修复版）`);
        } catch (error) {
            console.error('播放语音过程中发生异常:', error);
        }
    },
    
    // 通用的Web Audio API声音播放函数
    _playSimpleSound(frequency, duration) {
        try {
            const audioContext = this._getAudioContext();
            if (!audioContext) return;
            
            // 创建振荡器和增益节点
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            // 连接节点
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // 设置参数
            oscillator.type = 'sine'; // 正弦波
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            
            // 设置音量（0.5表示中等音量）
            gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
            
            // 添加淡出效果避免爆音
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
            
            // 播放声音
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        } catch (e) {
            console.error('播放声音失败:', e);
        }
    }
};

// DOM元素引用
const elements = {
    // 主步骤容器
    characterSelection: document.getElementById('character-selection'),
    storyExperience: document.getElementById('story-experience'),
    battleMode: document.getElementById('battle-mode'),
    achievementModal: document.getElementById('achievement-modal'),
    
    // 角色选择相关
    characterCards: document.querySelectorAll('.character-card'),
    
    // 进度条相关元素
    cyberProgressFill: document.querySelector('.cyber-progress .progress-fill'),
    cyberProgressInfo: document.querySelector('.cyber-progress .progress-info'),
    heritageProgressFill: document.querySelector('.heritage-progress .progress-fill'),
    heritageProgressInfo: document.querySelector('.heritage-progress .progress-info'),
    spaceProgressFill: document.querySelector('.space-progress .progress-fill'),
    spaceProgressInfo: document.querySelector('.space-progress .progress-info'),
    mathProgressFill: document.querySelector('.math-progress .progress-fill'),
    mathProgressInfo: document.querySelector('.math-progress .progress-info'),
    
    // 故事体验相关
    storyTitle: document.getElementById('story-title'),
    storyNarration: document.getElementById('story-narration'),
    storyChoices: document.getElementById('story-choices'),
    nextStoryBtn: document.getElementById('next-story'),
    backToSelectionBtn: document.getElementById('back-to-selection'),
    
    // 战斗模式相关
    battleTitle: document.getElementById('battle-title'),
    currentQuestion: document.getElementById('current-question'),
    totalQuestions: document.getElementById('total-questions'),
    questionContainer: document.getElementById('question-container'),
    optionsContainer: document.getElementById('options-container'),
    feedback: document.getElementById('feedback'),
    nextQuestionBtn: document.getElementById('next-question'),
    backToStoryBtn: document.getElementById('back-to-story'),
    
    // 成就弹窗相关
    achievementTitleText: document.getElementById('achievement-title-text'),
    achievementDescription: document.getElementById('achievement-description'),
    achievementIcon: document.getElementById('achievement-icon'),
    restartJourneyBtn: document.getElementById('restart-journey'),
    
    // 关卡信息相关
    levelTitle: document.getElementById('level-title'),
    levelDescription: document.getElementById('level-description'),
    levelGoal: document.getElementById('level-goal'),
    
    // 继续按钮
    continueBtn: document.getElementById('continue-btn')
};

// 角色总关卡数定义
const characterTotalLevels = {
    cyber: characters.cyber.levels.length,
    heritage: characters.heritage.levels.length,
    space: characters.space.levels.length,
    math: characters.math.levels.length
};

// 初始化应用
function initApp() {
    // 加载本地存储的数据
    loadFromLocalStorage();
    
    // 确保所有需要的状态字段都已初始化
    if (!appState.levelAttempts) {
        appState.levelAttempts = {
            level1: 0,
            level2: 0,
            level3: 0
        };
    }
    
    if (!appState.retryQuestions) {
        appState.retryQuestions = [];
    }
    
    if (!appState.analytics) {
        appState.analytics = {
            totalPlays: 0,
            characterSelection: {
                cyber: 0,
                heritage: 0,
                space: 0,
                math: 0
            },
            storyConversion: 0,
            battleCompletion: 0,
            levelCompletions: {},
            purchasePrompts: 0
        };
    }
    
    // 绑定事件监听器
    bindEventListeners();
    
    // 更新UI显示
    updateUI();
    
    // 更新所有角色的进度显示
    updateAllCharacterProgress();
    
    // 延迟启动粒子动画，确保DOM完全加载
    setTimeout(() => {
        if (typeof startParticleAnimation === 'function') {
            startParticleAnimation();
        } else {
            console.log('粒子动画功能未加载，尝试稍后重新加载...');
        }
    }, 500);
}

// 绑定事件监听器
function bindEventListeners() {
    // 角色选择卡片点击事件
    elements.characterCards.forEach(card => {
        card.addEventListener('click', () => {
            const characterId = card.getAttribute('data-character');
            selectCharacter(characterId);
        });
    });
    
    // 返回按钮事件
    elements.backToSelectionBtn.addEventListener('click', goBackToSelection);
    elements.backToStoryBtn.addEventListener('click', goBackToStory);
    
    // 继续按钮事件
    elements.nextStoryBtn.addEventListener('click', nextStory);
    elements.nextQuestionBtn.addEventListener('click', nextQuestion);
    
    // 重启旅程按钮事件
    elements.restartJourneyBtn.addEventListener('click', restartJourney);
}

// 选择角色
function selectCharacter(characterId) {
    appState.selectedCharacter = characterId;
    appState.currentStoryIndex = 0;
    appState.currentStep = 'story';
    
    // 播放角色选择音效
    soundEffects.playCharacterSelect(characterId);
    
    // 更新埋点数据
    appState.analytics.characterSelection[characterId]++;
    appState.analytics.totalPlays++;
    
    // 保存到本地存储
    saveToLocalStorage();
    
    // 更新UI
    updateUI();
}

// 下一个故事段落
function nextStory() {
    if (!appState.selectedCharacter) return;
    
    const character = characters[appState.selectedCharacter];
    appState.currentStoryIndex++;
    
    // 播放故事进度音效
    soundEffects.playStoryProgress();
    
    // 检查是否已经完成所有故事段落
    if (appState.currentStoryIndex >= character.story.length) {
        // 检查是否需要进入战斗模式
        if (character.story[character.story.length - 1].startBattle) {
            startBattle();
        }
        return;
    }
    
    // 更新UI
    updateUI();
}

// 开始战斗（答题）模式
function startBattle() {
    appState.currentStep = 'battle';
    appState.currentLevel = 1;
    appState.currentQuestionIndex = 0;
    appState.selectedOptions = [];
    appState.score = 0;
    appState.lives = 3;
    appState.retryQuestions = [];
    appState.levelAttempts = {
        level1: 0,
        level2: 0,
        level3: 0
    };
    
    // 更新埋点数据
    appState.analytics.storyConversion++;
    
    // 保存到本地存储
    saveToLocalStorage();
    
    // 更新UI
    updateUI();
}

// 选择答案
function selectAnswer(index) {
    if (!appState.selectedCharacter) return;
    
    const currentCharacter = characters[appState.selectedCharacter];
    const currentLevel = currentCharacter.levels[appState.currentLevel - 1];
    
    // 判断是显示错题还是正常题目
    let question, isRetryQuestion = false;
    if (appState.retryQuestions.length > 0) {
        question = appState.retryQuestions[0];
        isRetryQuestion = true;
    } else {
        question = currentLevel.questions[appState.currentQuestionIndex];
    }
    
    const isCorrect = index === question.correctIndex;
    
    if (isCorrect) {
        appState.score++;
        
        // 如果是错题重练，从错题列表中移除
        if (isRetryQuestion) {
            appState.retryQuestions.shift();
        }
    } else {
        appState.lives--;
        
        // 如果回答错误，将题目添加到错题列表末尾
        if (!isRetryQuestion) {
            appState.retryQuestions.push(question);
        }
    }
    
    // 显示反馈
    showFeedback(isCorrect, question.explanation);
    
    // 禁用所有选项
    const options = elements.optionsContainer.querySelectorAll('.option');
    options.forEach((option, i) => {
        option.disabled = true;
        if (i === index) {
            option.classList.add(isCorrect ? 'correct' : 'incorrect');
        } else if (i === question.correctIndex) {
            option.classList.add('correct');
        }
    });
    
    // 显示下一题按钮
    elements.nextQuestionBtn.classList.remove('hidden');
    
    // 保存到本地存储
    saveToLocalStorage();
}

// 生成部分解析内容（用于第四个及以后的错题）
function generatePartialExplanation(explanation) {
    // 部分解析包含基本的解题思路和被马赛克遮挡的完整解析框架
    let partialContent = '';
    
    // 计算解析完成度比例（部分解析显示约30%内容）
    const completionPercentage = 30;
    
    partialContent += `
        <div class="explanation-section">
            <h4 class="explanation-title">🔍 解题思路</h4>
            <div class="solution-steps">
                <div class="solution-step">
                    <span class="step-icon">△</span>
                    <span class="step-content">这道题目的关键在于理解${explanation.substring(0, 30)}...</span>
                </div>
            </div>
        </div>
        
        <!-- 以下部分被马赛克遮挡 -->
        <div class="explanation-section masked-section">
            <div class="masked-content">
                <h4 class="explanation-title">📚 考查知识点</h4>
                <p>这里隐藏了关键的知识点...</p>
            </div>
            <div class="mask-overlay">
                <div class="mask-pattern"></div>
                <div class="mask-text">
                    <span class="lock-icon">🔒</span>
                    <span>分享解锁剩余 ${100 - completionPercentage}% 内容</span>
                </div>
            </div>
        </div>
        
        <div class="explanation-section masked-section">
            <div class="masked-content">
                <h4 class="explanation-title">🔍 解题过程</h4>
                <div class="solution-steps">
                    <div class="solution-step">
                        <span class="step-icon">→</span>
                        <span class="step-content">这里隐藏了详细的解题步骤...</span>
                    </div>
                </div>
            </div>
            <div class="mask-overlay">
                <div class="mask-pattern"></div>
                <div class="mask-text">
                    <span class="lock-icon">🔒</span>
                    <span>分享解锁剩余 ${100 - completionPercentage}% 内容</span>
                </div>
            </div>
        </div>
        
        <div class="explanation-section masked-section">
            <div class="masked-content">
                <h4 class="explanation-title">⚠️ 常见误区</h4>
                <p>这里隐藏了常见误区分析...</p>
            </div>
            <div class="mask-overlay">
                <div class="mask-pattern"></div>
                <div class="mask-text">
                    <span class="lock-icon">🔒</span>
                    <span>分享解锁剩余 ${100 - completionPercentage}% 内容</span>
                </div>
            </div>
        </div>
        
        <div class="explanation-section masked-section">
            <div class="masked-content">
                <h4 class="explanation-title">💡 解题技巧</h4>
                <p>这里隐藏了解题技巧分享...</p>
            </div>
            <div class="mask-overlay">
                <div class="mask-pattern"></div>
                <div class="mask-text">
                    <span class="lock-icon">🔒</span>
                    <span>分享解锁剩余 ${100 - completionPercentage}% 内容</span>
                </div>
            </div>
        </div>`;
    
    return partialContent;
}

// 生成详细的题目解析
function generateDetailedExplanation(explanation, question) {
    // 默认的详细解析，会根据传入的explanation和question内容进行增强
    let detailedContent = '';
    
    // 1. 拆解题目考查的知识点
    if (question.knowledgePoint) {
        detailedContent += `
        <div class="explanation-section">
            <h4 class="explanation-title">📚 考查知识点</h4>
            <p>${question.knowledgePoint}</p>
        </div>`;
    } else {
        detailedContent += `
        <div class="explanation-section">
            <h4 class="explanation-title">📚 考查知识点</h4>
            <p>本题主要考查了解题者对相关概念的理解和应用能力。</p>
        </div>`;
    }
    
    // 2. 分步骤演示解题过程
    let stepByStep = '';
    if (question.solutionSteps && Array.isArray(question.solutionSteps)) {
        stepByStep = question.solutionSteps.map((step, index) => {
            const stepIcon = ['△', '→', '★', '✓', '➤'][index % 5];
            return `
            <div class="solution-step">
                <span class="step-icon">${stepIcon}</span>
                <span class="step-content">${step}</span>
            </div>`;
        }).join('');
    } else if (explanation) {
        // 如果没有预定义的步骤，尝试从explanation中提取关键步骤
        stepByStep = `
            <div class="solution-step">
                <span class="step-icon">△</span>
                <span class="step-content">首先，我们需要明确题目要求和已知条件。</span>
            </div>
            <div class="solution-step">
                <span class="step-icon">→</span>
                <span class="step-content">${explanation}</span>
            </div>
            <div class="solution-step">
                <span class="step-icon">★</span>
                <span class="step-content">通过以上分析，可以得出正确答案。</span>
            </div>`;
    }
    
    detailedContent += `
        <div class="explanation-section">
            <h4 class="explanation-title">🔍 解题过程</h4>
            <div class="solution-steps">${stepByStep}</div>
        </div>`;
    
    // 3. 针对错误选项说明常见误区
    if (question.commonMistakes) {
        detailedContent += `
        <div class="explanation-section">
            <h4 class="explanation-title">⚠️ 常见误区</h4>
            <p>${question.commonMistakes}</p>
        </div>`;
    } else {
        detailedContent += `
        <div class="explanation-section">
            <h4 class="explanation-title">⚠️ 常见误区</h4>
            <p>在解答此类题目时，容易忽略细节或混淆概念。请仔细审题，明确各个条件之间的关系。</p>
        </div>`;
    }
    
    // 4. 补充同类题型的解题技巧
    if (question.solutionTips) {
        detailedContent += `
        <div class="explanation-section">
            <h4 class="explanation-title">💡 解题技巧</h4>
            <p>${question.solutionTips}</p>
        </div>`;
    } else {
        detailedContent += `
        <div class="explanation-section">
            <h4 class="explanation-title">💡 解题技巧</h4>
            <p>解决这类问题时，可以尝试：1) 仔细分析题目条件；2) 列出已知信息和要求；3) 逐步推导；4) 验证答案的合理性。</p>
        </div>`;
    }
    
    return detailedContent;
}

// 显示答题反馈
function showFeedback(isCorrect, explanation) {
    // 如果回答正确，播放成功音效
    if (isCorrect) {
        soundEffects.playSuccess();
    }
    // 获取当前问题以获取人生启示
    let question;
    const character = characters[appState.selectedCharacter];
    const currentLevel = character.levels[appState.currentLevel - 1];
    
    // 判断是显示错题还是正常题目
    if (appState.retryQuestions.length > 0) {
        question = appState.retryQuestions[0];
    } else {
        question = currentLevel.questions[appState.currentQuestionIndex];
    }
    
    // 多样化人物形象口吻的反馈文案
    const characterStyles = {
        '总裁': [
            '很好，这种解题思路很对我的胃口。继续保持，我欣赏你这种逻辑清晰的人。',
            '不错，这个问题处理得很到位。作为我的人，就该有这种敏锐的洞察力。',
            '很好，完全正确！看来你已经掌握了其中的精髓。',
            '回答得漂亮！我从不夸人，但这次我要给你点个赞。',
            '非常好，思路清晰，逻辑严密。这才是我认可的水平。'
        ],
        '二次元': [
            '哇塞～你超厉害的耶！这个问题都能答对，简直是学霸属性全开呢！✨',
            '太棒啦！你一定是隐藏的数学大佬吧？膜拜ing～',
            '好厉害！这个解法太神了，感觉你在发光呢！',
            '正确！你的智商简直突破天际啦，我要给你打call！',
            '耶！答对了！你真是个天才，爱了爱了～'
        ],
        '萌妹': [
            '哇～你好棒哦！这个题目人家想了好久都没头绪的说～',
            '太厉害了啦～怎么可以这么聪明呢？好崇拜你哦～',
            '哇塞！完全正确呢～你是不是偷偷复习了呀？',
            '太棒了啦！这个解法超厉害的，人家都没想到呢～',
            '对了对了！你好聪明哦，我都要给你点一百个赞～'
        ],
        '学者': [
            '很好，你的解答展现了清晰的逻辑思维和扎实的基础知识。',
            '正确，这个问题的关键就在于你所掌握的这个规律。',
            '非常精彩，你已经触及到了这个问题的本质。',
            '恭喜你，你的思考过程完全符合科学的方法论。',
            '很好，你的解答验证了我们之前讨论的理论的正确性。'
        ],
        '武侠': [
            '好！这一招使得妙！看来你已深得此道精髓！',
            '不错！解法干脆利落，颇有大家风范！',
            '妙哉！此等解题思路，当真如同剑走偏锋，精妙绝伦！',
            '好功夫！这道题的难点被你一击中的，佩服佩服！',
            '痛快！你的解法如同行云流水，毫无凝滞，真乃高手！'
        ]
    };
    
    let feedbackHTML = '';
    if (isCorrect) {
        // 随机选择一种人物风格
        const styles = Object.keys(characterStyles);
        const randomStyle = styles[Math.floor(Math.random() * styles.length)];
        const styleMessages = characterStyles[randomStyle];
        const randomMessage = styleMessages[Math.floor(Math.random() * styleMessages.length)];
        
        // 构建反馈HTML，不显示口吻标签
        feedbackHTML = `
            <div class="feedback-style">${randomMessage}</div>
        `;
        
        // 播放对应口吻的语音反馈
        soundEffects.playFeedbackVoice(randomStyle);
        
        // 如果有人生启示，以独立字体颜色突出显示
        if (question.lifeLesson) {
            feedbackHTML += `
                <div class="feedback-lesson">
                    <span class="lesson-icon">💡</span>
                    <span class="lesson-text">${question.lifeLesson}</span>
                </div>
            `;
        }
    } else {
        // 增加当前关卡的错题计数
        const levelKey = `level${appState.currentLevel}`;
        appState.wrongAnswersCount[levelKey] = (appState.wrongAnswersCount[levelKey] || 0) + 1;
        
        // 根据错题数量决定显示完整解析还是部分解析
        const wrongCount = appState.wrongAnswersCount[levelKey];
        if (wrongCount <= 3) {
            // 前三个错题显示完整解析
            const detailedExplanation = generateDetailedExplanation(explanation, question);
            feedbackHTML = `<div class="feedback-wrong">回答错误。</div>
                            <div class="detailed-explanation">${detailedExplanation}</div>`;
        } else {
            // 第四个及以后的错题显示部分解析
            const partialExplanation = generatePartialExplanation(explanation);
            const friendCountToUnlock = 3; // 每邀请3位好友可解锁新功能
            const unlockedFeature = '高级解析库'; // 解锁的新功能
            
            feedbackHTML = `<div class="feedback-wrong">回答错误。</div>
                            <div class="detailed-explanation">${partialExplanation}</div>
                            <div class="share-locked-explanation">
                                <p>🎯 您已查看了本关卡的3个完整解析</p>
                                <p>💡 分享给好友可解锁此解析的完整内容</p>
                                <button class="share-button floating-button pulse-animation">分享好友解锁完整版</button>
                                <div class="reward-info">
                                    <div class="reward-icon">🎁</div>
                                    <div class="reward-text">
                                        <div class="reward-title">额外奖励</div>
                                        <div class="reward-description">每成功邀请${friendCountToUnlock}人，可解锁${unlockedFeature}！</div>
                                    </div>
                                </div>
                            </div>`;
        }
    }
    
    // 增加当前关卡的尝试次数（仅在回答错误时）
    if (!isCorrect) {
        const levelKey = `level${appState.currentLevel}`;
        appState.levelAttempts[levelKey] = (appState.levelAttempts[levelKey] || 0) + 1;
        
        // 检查是否需要显示购买引导
        if (appState.levelAttempts[levelKey] >= 3) {
            // 显示购买引导弹窗
            setTimeout(() => {
                showPurchasePrompt();
            }, 1500);
        }
    }
    
    elements.feedback.innerHTML = feedbackHTML;
    elements.feedback.className = `feedback ${isCorrect ? 'correct' : 'incorrect'}`;
    elements.feedback.classList.remove('hidden');
    
    // 为分享按钮添加点击事件监听
    if (!isCorrect) {
        const shareButton = elements.feedback.querySelector('.share-button');
        if (shareButton) {
            shareButton.addEventListener('click', () => {
                // 这里可以实现实际的分享逻辑
                // 由于是模拟环境，我们只显示一个提示信息
                alert('分享功能已触发！在实际环境中，这里会调用分享API或显示分享弹窗。');
                
                // 为了演示目的，点击后可以解锁当前解析
                // 在实际应用中，这里应该等待用户完成分享操作后再解锁
                const levelKey = `level${appState.currentLevel}`;
                const wrongCount = appState.wrongAnswersCount[levelKey];
                
                if (wrongCount > 3) {
                    // 生成并显示完整解析
                    const detailedExplanation = generateDetailedExplanation(explanation, question);
                    const explanationElement = elements.feedback.querySelector('.detailed-explanation');
                    const lockedElement = elements.feedback.querySelector('.share-locked-explanation');
                    
                    if (explanationElement && lockedElement) {
                        explanationElement.innerHTML = detailedExplanation;
                        lockedElement.innerHTML = '<p>🎉 恭喜！您已成功解锁完整解析！</p>';
                        lockedElement.classList.remove('share-locked-explanation');
                        lockedElement.classList.add('unlocked-explanation');
                    }
                }
            });
        }
    }
}

// 进入下一题或下一关
function nextQuestion() {
    if (!appState.selectedCharacter) return;
    
    const character = characters[appState.selectedCharacter];
    
    // 如果有错题需要重练，继续留在当前关卡
    if (appState.retryQuestions.length > 0) {
        updateBattleUI();
        return;
    }
    
    const currentLevel = character.levels[appState.currentLevel - 1];
    
    // 检查是否完成了当前关卡的所有题目
    if (appState.currentQuestionIndex >= currentLevel.questions.length) {
        // 完成当前关卡
        const levelKey = `level${appState.currentLevel}`;
        
        // 重置关卡尝试次数
        appState.levelAttempts[levelKey] = 0;
        
        // 显示关卡完成成就（如果有的话）
        const levelAchievement = character.achievements[levelKey];
        if (levelAchievement) {
            showAchievement(levelAchievement);
            return; // 如果显示了成就弹窗，就不再继续下面的逻辑
        }
        
        // 记录关卡完成情况
        appState.analytics.levelCompletions[appState.selectedCharacter] = appState.currentLevel;
        saveToLocalStorage();
        
        // 检查是否还有下一关
        const nextLevelIndex = appState.currentLevel;
        if (nextLevelIndex < character.levels.length) {
            // 准备下一关信息
            const nextLevel = character.levels[nextLevelIndex];
            
            // 显示当前关卡成功信息和下一关卡引导提示
            elements.feedback.innerHTML = `
                <div>${currentLevel.successMessage}</div>
                <div style="margin-top: 15px; font-size: 1.1em;">下一关: ${nextLevel.title}</div>
                <div style="margin-top: 5px; color: var(--accent-color-3);">${nextLevel.description}</div>
            `;
            elements.feedback.style.display = 'block';
            elements.feedback.style.textAlign = 'center';
            elements.feedback.style.padding = '20px';
            elements.feedback.style.backgroundColor = 'rgba(255, 255, 255, 0.95)';
            elements.feedback.style.borderRadius = '10px';
            elements.feedback.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.15)';
            
            // 检查继续按钮是否存在，防止未定义错误
            if (elements.continueBtn) {
                // 显示继续按钮
                elements.continueBtn.textContent = '继续闯关';
                elements.continueBtn.classList.remove('hidden');
                
                // 为继续按钮添加点击事件
                elements.continueBtn.onclick = () => {
                    // 进入下一关
                    appState.currentLevel++;
                    appState.currentQuestionIndex = 0;
                    
                    // 隐藏反馈和继续按钮
                    elements.feedback.style.display = 'none';
                    elements.continueBtn.classList.add('hidden');
                    
                    // 更新UI，进入下一关的刷题界面
                    updateBattleUI();
                };
            } else {
                // 如果继续按钮不存在，使用nextQuestionBtn作为替代
                if (elements.nextQuestionBtn) {
                    elements.nextQuestionBtn.textContent = '继续闯关';
                    elements.nextQuestionBtn.classList.remove('hidden');
                    
                    // 临时存储原始点击事件处理程序
                    const originalNextQuestionHandler = elements.nextQuestionBtn.onclick;
                    
                    // 设置临时点击事件处理程序
                    elements.nextQuestionBtn.onclick = () => {
                        // 进入下一关
                        appState.currentLevel++;
                        appState.currentQuestionIndex = 0;
                        
                        // 隐藏反馈
                        elements.feedback.style.display = 'none';
                        
                        // 恢复原始点击事件处理程序
                        elements.nextQuestionBtn.textContent = '下一题';
                        elements.nextQuestionBtn.onclick = originalNextQuestionHandler;
                        
                        // 更新UI，进入下一关的刷题界面
                        updateBattleUI();
                    };
                }
            }
        } else {
            // 完成所有关卡，显示最终成就
            setTimeout(() => {
                showAchievement(character.achievements.final);
            }, 2000);
        }
    } else {
        // 没有完成当前关卡，继续下一题
        appState.currentQuestionIndex++;
        updateBattleUI();
    }
}

// 显示购买引导弹窗
function showPurchasePrompt() {
    // 首先移除可能存在的旧弹窗
    const oldModal = document.getElementById('purchase-modal');
    if (oldModal) {
        oldModal.remove();
    }
    
    // 创建购买引导弹窗
    const purchaseModal = document.createElement('div');
    purchaseModal.id = 'purchase-modal';
    purchaseModal.style.position = 'fixed';
    purchaseModal.style.top = '0';
    purchaseModal.style.left = '0';
    purchaseModal.style.width = '100%';
    purchaseModal.style.height = '100%';
    purchaseModal.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
    purchaseModal.style.display = 'flex';
    purchaseModal.style.justifyContent = 'center';
    purchaseModal.style.alignItems = 'center';
    purchaseModal.style.zIndex = '1001';
    
    const modalContent = document.createElement('div');
    modalContent.style.backgroundColor = 'white';
    modalContent.style.padding = '30px';
    modalContent.style.borderRadius = '10px';
    modalContent.style.textAlign = 'center';
    modalContent.style.maxWidth = '500px';
    modalContent.style.width = '90%';
    modalContent.style.boxShadow = '0 4px 12px rgba(108, 92, 231, 0.3)';
    
    // 添加标题
    const titleContainer = document.createElement('div');
    titleContainer.style.marginBottom = '15px';
    titleContainer.style.animation = 'modalPulse 2s infinite';
    
    const title = document.createElement('h2');
    title.textContent = '突破学习瓶颈';
    title.style.color = '#6c5ce7';
    title.style.margin = '0';
    titleContainer.appendChild(title);
    modalContent.appendChild(titleContainer);
    
    // 添加描述文本
    const description = document.createElement('p');
    description.style.marginBottom = '20px';
    description.style.fontSize = '16px';
    description.style.lineHeight = '1.5';
    description.innerHTML = '<strong>别让错题阻碍你前进！</strong><br>你在这一关卡已经遇到了挑战，现在是时候获取专业帮助了。我们的<span style="color: #6c5ce7;">金牌导师1对1指导</span>能帮你：';
    modalContent.appendChild(description);
    
    // 添加核心价值列表
    const featureList = document.createElement('ul');
    featureList.style.textAlign = 'left';
    featureList.style.margin = '0 auto 25px auto';
    featureList.style.maxWidth = '350px';
    featureList.style.paddingLeft = '0';
    featureList.style.listStyle = 'none';
    
    const features = [
        '精准分析错误原因，避免重复犯错',
        '掌握高效解题技巧，提升学习效率',
        '快速突破关卡，重拾学习信心'
    ];
    
    features.forEach(text => {
        const featureItem = document.createElement('li');
        featureItem.style.marginBottom = '12px';
        featureItem.style.paddingLeft = '30px';
        featureItem.style.position = 'relative';
        featureItem.style.fontSize = '16px';
        featureItem.style.lineHeight = '1.4';
        
        // 使用span元素显示勾选标记，确保兼容性
        const checkMark = document.createElement('span');
        checkMark.textContent = '✓';
        checkMark.style.color = '#6c5ce7';
        checkMark.style.fontWeight = 'bold';
        checkMark.style.position = 'absolute';
        checkMark.style.left = '0';
        checkMark.style.top = '0';
        
        const textSpan = document.createElement('span');
        textSpan.textContent = text;
        
        featureItem.appendChild(checkMark);
        featureItem.appendChild(textSpan);
        featureList.appendChild(featureItem);
    });
    
    modalContent.appendChild(featureList);
    
    // 添加按钮容器
    const buttonContainer = document.createElement('div');
    buttonContainer.style.display = 'flex';
    buttonContainer.style.gap = '15px';
    buttonContainer.style.justifyContent = 'center';
    
    // 添加购买按钮
    const purchaseButton = document.createElement('button');
    purchaseButton.id = 'purchase-yes';
    purchaseButton.textContent = '立即解锁导师指导';
    purchaseButton.style.background = 'linear-gradient(135deg, #6c5ce7, #8e44ad)';
    purchaseButton.style.color = 'white';
    purchaseButton.style.border = 'none';
    purchaseButton.style.padding = '12px 24px';
    purchaseButton.style.borderRadius = '5px';
    purchaseButton.style.cursor = 'pointer';
    purchaseButton.style.fontSize = '16px';
    purchaseButton.style.fontWeight = 'bold';
    purchaseButton.style.boxShadow = '0 4px 12px rgba(108, 92, 231, 0.4)';
    
    // 添加悬停效果
    purchaseButton.onmouseover = function() {
        this.style.transform = 'translateY(-2px)';
        this.style.boxShadow = '0 6px 20px rgba(108, 92, 231, 0.5)';
        this.style.transition = 'all 0.3s ease';
    };
    
    purchaseButton.onmouseout = function() {
        this.style.transform = 'translateY(0)';
        this.style.boxShadow = '0 4px 12px rgba(108, 92, 231, 0.4)';
    };
    
    // 添加取消按钮
    const declineButton = document.createElement('button');
    declineButton.id = 'purchase-no';
    declineButton.textContent = '暂时不需要';
    declineButton.style.backgroundColor = '#f1f1f1';
    declineButton.style.color = '#666';
    declineButton.style.border = '1px solid #ddd';
    declineButton.style.padding = '12px 24px';
    declineButton.style.borderRadius = '5px';
    declineButton.style.cursor = 'pointer';
    declineButton.style.fontSize = '16px';
    
    // 添加悬停效果
    declineButton.onmouseover = function() {
        this.style.backgroundColor = '#e8e8e8';
        this.style.transition = 'all 0.3s ease';
    };
    
    declineButton.onmouseout = function() {
        this.style.backgroundColor = '#f1f1f1';
    };
    
    buttonContainer.appendChild(purchaseButton);
    buttonContainer.appendChild(declineButton);
    modalContent.appendChild(buttonContainer);
    
    // 添加动画样式到页面头部
    const styleId = 'purchase-modal-styles';
    let styleElement = document.getElementById(styleId);
    if (!styleElement) {
        styleElement = document.createElement('style');
        styleElement.id = styleId;
        document.head.appendChild(styleElement);
    }
    styleElement.textContent = `
        @keyframes modalPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }
    `;
    
    purchaseModal.appendChild(modalContent);
    document.body.appendChild(purchaseModal);
    
    // 购买按钮事件处理
    purchaseButton.onclick = function() {
        alert('感谢你的支持！私教服务即将上线，敬请期待！');
        purchaseModal.remove();
    };
    
    // 取消按钮事件处理
    declineButton.onclick = function() {
        purchaseModal.remove();
    };
    
    // 更新埋点数据
    appState.analytics.purchasePrompts = (appState.analytics.purchasePrompts || 0) + 1;
}

// 显示成就
function showAchievement(achievement = null) {
    if (!appState.selectedCharacter) return;
    
    const character = characters[appState.selectedCharacter];
    
    // 如果没有传入具体成就，则显示最终成就
    if (!achievement) {
        achievement = character.achievements.final;
    }
    
    // 更新成就信息
    elements.achievementTitleText.textContent = `恭喜获得「${achievement.name}」`;
    elements.achievementDescription.textContent = achievement.description;
    elements.achievementIcon.textContent = achievement.icon;
    
    // 添加角色主题色
    elements.achievementIcon.className = `achievement-icon ${appState.selectedCharacter}-theme`;
    
    // 根据成就类型设置按钮文本
    if (achievement.name === character.achievements.final.name) {
        elements.restartJourneyBtn.textContent = '开启新的旅程';
    } else {
        elements.restartJourneyBtn.textContent = '继续闯关';
    }
    
    // 显示成就弹窗
    appState.currentStep = 'achievement';
    
    // 更新埋点数据
    appState.analytics.battleCompletion++;
    
    // 保存成就到本地存储
    saveAchievementToLocalStorage(achievement.name);
    saveToLocalStorage();
    
    // 更新UI
    updateUI();
    
    // 更新所有角色的进度显示
    updateAllCharacterProgress();
}

// 返回角色选择
function goBackToSelection() {
    appState.currentStep = 'selection';
    updateUI();
}

// 返回故事体验
function goBackToStory() {
    appState.currentStep = 'story';
    updateUI();
}

// 重启旅程或继续闯关
function restartJourney() {
    // 隐藏成就弹窗
    elements.achievementModal.classList.remove('active');
    
    const character = characters[appState.selectedCharacter];
    
    // 检查当前是否是最终成就
    const currentAchievementName = elements.achievementTitleText.textContent.match(/「(.*?)」/);
    const isFinalAchievement = currentAchievementName && 
                              currentAchievementName[1] === character.achievements.final.name;
    
    if (isFinalAchievement) {
        // 完成所有关卡后，重置游戏状态
        appState.currentStep = 'selection';
        appState.selectedCharacter = null;
        appState.currentStoryIndex = 0;
        appState.currentLevel = 1;
        appState.currentQuestionIndex = 0;
        appState.selectedOptions = [];
        appState.score = 0;
        appState.levelAttempts = {};
        appState.retryQuestions = [];
    } else {
        // 关卡完成后，继续到下一关卡
        appState.currentStep = 'battle';
        appState.currentLevel++;
        appState.currentQuestionIndex = 0;
    }
    
    // 更新UI
    updateUI();
}

// 更新UI
function updateUI() {
    // 隐藏所有步骤
    elements.characterSelection.classList.remove('active');
    elements.storyExperience.classList.remove('active');
    elements.battleMode.classList.remove('active');
    elements.achievementModal.classList.remove('active');
    
    // 根据当前步骤显示对应内容
    switch (appState.currentStep) {
        case 'selection':
            elements.characterSelection.classList.add('active');
            break;
            
        case 'story':
            elements.storyExperience.classList.add('active');
            updateStoryUI();
            break;
            
        case 'battle':
            elements.battleMode.classList.add('active');
            updateBattleUI();
            break;
            
        case 'achievement':
            elements.achievementModal.classList.add('active');
            break;
    }
}

// 流式文字输出效果
function typewriterEffect(element, text, callback) {
    if (!element || !text) return;
    
    // 清空元素内容
    element.innerHTML = '';
    
    let index = 0;
    const speed = 30; // 每个字符的延迟时间（毫秒）
    
    // 提取文本中的角色名称和关键术语
    const characterName = characters[appState.selectedCharacter]?.name || '';
    
    // 定义关键术语列表（可以根据不同角色动态生成）
    const techTerms = getTechTermsByCharacter(appState.selectedCharacter);
    
    function typeNextChar() {
        if (index < text.length) {
            let currentChar = text.charAt(index);
            let nextChars = text.substring(index);
            let charElement = document.createElement('span');
            charElement.className = 'typewriter-char';
            charElement.style.animationDelay = `${index * 0.02}s`;
            
            let termFound = false;
            
            // 检查是否是角色名称的开始
            if (nextChars.startsWith(characterName)) {
                // 创建角色名称的span元素
                const nameElement = document.createElement('span');
                nameElement.className = 'typewriter-char role-name';
                nameElement.style.animationDelay = `${index * 0.02}s`;
                nameElement.textContent = characterName;
                element.appendChild(nameElement);
                index += characterName.length;
                termFound = true;
            }
            // 检查是否是关键术语的开始 - 修复可能导致字符缺失的问题
            else {
                // 检查是否存在任何关键术语
                const matchingTerm = techTerms.find(term => nextChars.startsWith(term));
                if (matchingTerm) {
                    // 创建关键术语的span元素
                    const termElement = document.createElement('span');
                    termElement.className = 'typewriter-char tech-term';
                    termElement.style.animationDelay = `${index * 0.02}s`;
                    termElement.textContent = matchingTerm;
                    element.appendChild(termElement);
                    index += matchingTerm.length;
                    termFound = true;
                }
            }
            
            // 普通字符
            if (!termFound) {
                // 确保所有字符（包括空格）都能正确处理
                charElement.textContent = currentChar === ' ' ? '\u00A0' : currentChar;
                element.appendChild(charElement);
                index++;
            }
            
            // 使用requestAnimationFrame确保流畅的动画
            requestAnimationFrame(() => {
                setTimeout(typeNextChar, speed);
            });
        } else {
            // 文本输出完成后调用回调函数
            if (typeof callback === 'function') {
                callback();
            }
        }
    }
    
    // 开始打字效果
    typeNextChar();
}

// 根据角色获取关键术语
function getTechTermsByCharacter(characterId) {
    const techTermsMap = {
        'cyber': ['人工智能', '机器学习', '神经网络', '算法', '数据挖掘', '深度学习', '代码', '编程'],
        'heritage': ['非遗', '传统工艺', '文化遗产', '手工艺', '戏曲', '书法', '国画', '传承'],
        'space': ['宇宙', '星球', '黑洞', '星系', '太空站', '航天', '天文', '行星'],
        'math': ['数学', '几何', '代数', '概率', '统计', '数列', '方程', '计算']
    };
    
    return techTermsMap[characterId] || [];
}

// 更新故事UI
function updateStoryUI() {
    if (!appState.selectedCharacter) return;
    
    const character = characters[appState.selectedCharacter];
    const storySection = character.story[appState.currentStoryIndex];
    
    // 更新故事标题 - 优化为更具吸引力的文案
    const titleMap = {
        'cyber': `开启Cyber侦探的数字冒险`,
        'heritage': `开启非遗守护人的文化传承之旅`,
        'space': `开启星球开拓者的星际探索`,
        'math': `开启数学探索家的人生之旅`
    };
    
    // 如果找不到对应角色的标题，使用默认格式
    const storyTitle = titleMap[appState.selectedCharacter] || `开启${character.name}的精彩旅程`;
    elements.storyTitle.textContent = storyTitle;
    
    // 使用流式文字输出效果更新故事内容
    typewriterEffect(elements.storyNarration, storySection.text, () => {
        // 文本输出完成后执行的操作
        // 例如显示选择项或继续按钮
        // 清除之前的选择项
        elements.storyChoices.innerHTML = '';
        
        // 隐藏/显示继续按钮
        if (storySection.next) {
            elements.nextStoryBtn.classList.remove('hidden');
        } else {
            elements.nextStoryBtn.classList.add('hidden');
        }
    });
}

// 更新战斗UI
function updateBattleUI() {
    if (!appState.selectedCharacter) return;
    
    const character = characters[appState.selectedCharacter];
    const currentLevel = character.levels[appState.currentLevel - 1];
    
    // 获取battle-header元素
    const battleHeader = elements.battleMode.querySelector('.battle-header');
    
    // 获取角色图标元素
    const characterIcon = document.getElementById('character-icon');
    
    // 角色图标映射表 - 使用更有趣、更具特色的表情符号
    const characterIcons = {
        'cyber': {
            1: '🕵️‍♂️', // 数字初入者 - 侦探形象
            2: '💻', // 数字进阶 - 专注工作的电脑专家
            3: '🔐', // 数字大师 - 网络安全专家
            default: '👨‍💻' // 默认科技达人
        },
        'heritage': {
            1: '🎭', // 文化初入者 - 戏剧面具（代表文化多样性）
            2: '📜', // 文化传承 - 古老卷轴
            3: '🏯', // 文化大师 - 古建筑守护者
            default: '🧙‍♂️' // 默认文化守护者
        },
        'space': {
            1: '🚀', // 星际初入者 - 火箭发射
            2: '👨‍🚀', // 星际探索 - 宇航员出舱
            3: '🪐', // 星际大师 - 行星探索者
            default: '🌠' // 默认太空异象
        },
        'math': {
            1: '🧮', // 数学初入者 - 老式计算器
            2: '🔬', // 数学进阶 - 科学探索
            3: '🧠', // 数学大师 - 智慧大脑
            default: '📊' // 默认数据分析师
        },
        default: {
            default: '🧩' // 默认拼图图标（代表探索未知）
        }
    };
    
    // 设置角色图标
    if (characterIcon) {
        const characterMap = characterIcons[appState.selectedCharacter] || characterIcons.default;
        const icon = characterMap[appState.currentLevel] || characterMap.default;
        characterIcon.textContent = icon;
        
        // 根据角色类型设置不同的图标背景颜色
        if (appState.selectedCharacter === 'cyber') {
            characterIcon.style.background = 'linear-gradient(135deg, rgba(0, 188, 212, 0.2), rgba(33, 150, 243, 0.2))';
            characterIcon.style.borderColor = 'rgba(0, 188, 212, 0.5)';
        } else if (appState.selectedCharacter === 'heritage') {
            characterIcon.style.background = 'linear-gradient(135deg, rgba(255, 193, 7, 0.2), rgba(255, 152, 0, 0.2))';
            characterIcon.style.borderColor = 'rgba(255, 193, 7, 0.5)';
        } else if (appState.selectedCharacter === 'space') {
            characterIcon.style.background = 'linear-gradient(135deg, rgba(156, 39, 176, 0.2), rgba(103, 58, 183, 0.2))';
            characterIcon.style.borderColor = 'rgba(156, 39, 176, 0.5)';
        } else if (appState.selectedCharacter === 'math') {
            characterIcon.style.background = 'linear-gradient(135deg, rgba(76, 175, 80, 0.2), rgba(0, 150, 136, 0.2))';
            characterIcon.style.borderColor = 'rgba(76, 175, 80, 0.5)';
        } else {
            characterIcon.style.background = 'linear-gradient(135deg, rgba(108, 99, 255, 0.2), rgba(142, 68, 173, 0.2))';
            characterIcon.style.borderColor = 'rgba(255, 255, 255, 0.3)';
        }
    }
    
    // 检查是否为cyber侦探的第一个关卡
    if (appState.selectedCharacter === 'cyber' && appState.currentLevel === 1) {
        battleHeader.classList.add('cyber-first-level');
    } else {
        battleHeader.classList.remove('cyber-first-level');
    }
    
    // 如果有错题需要重练，则优先显示错题
    let question;
    if (appState.retryQuestions.length > 0) {
        question = appState.retryQuestions[0];
    } else {
        question = currentLevel.questions[appState.currentQuestionIndex];
    }
    
    // 更新关卡标题
    if (elements.levelTitle && currentLevel.title) {
        elements.levelTitle.textContent = currentLevel.title;
    }
    
    // 更新关卡描述
    if (elements.levelDescription && currentLevel.description) {
        elements.levelDescription.textContent = currentLevel.description;
    }
    
    // 隐藏人生目标元素
    if (elements.levelGoal) {
        elements.levelGoal.classList.add('hidden');
    }
    
    // 完全隐藏battle-title元素，不再显示'知识挑战'字样
    if (elements.battleTitle) {
        elements.battleTitle.classList.add('hidden');
    }
    
    // 更新进度指示器
    const totalQuestionsInLevel = appState.retryQuestions.length > 0 ? appState.retryQuestions.length : currentLevel.questions.length;
    elements.currentQuestion.textContent = appState.currentQuestionIndex + 1;
    elements.totalQuestions.textContent = totalQuestionsInLevel;
    
    // 更新题目内容
    const questionContentElement = elements.questionContainer.querySelector('.question-content');
    if (questionContentElement) {
        questionContentElement.textContent = question.content;
    } else {
        // 回退方案，确保旧版HTML也能正常工作
        elements.questionContainer.textContent = question.content;
    }
    
    // 清除之前的选项
    elements.optionsContainer.innerHTML = '';
    
    // 添加选项
    question.options.forEach((option, index) => {
        const optionElement = document.createElement('div');
        optionElement.className = 'option';
        optionElement.textContent = option;
        optionElement.addEventListener('click', () => selectAnswer(index));
        elements.optionsContainer.appendChild(optionElement);
    });
    
    // 隐藏反馈和下一题按钮
    elements.feedback.classList.add('hidden');
    elements.nextQuestionBtn.classList.add('hidden');
}

// 保存到本地存储
function saveToLocalStorage() {
    try {
        localStorage.setItem('gameState', JSON.stringify(appState));
    } catch (error) {
        console.error('保存游戏状态失败:', error);
    }
}

// 从本地存储加载
function loadFromLocalStorage() {
    try {
        const savedState = localStorage.getItem('gameState');
        if (savedState) {
            const parsedState = JSON.parse(savedState);
            // 加载需要持久化的状态
            if (parsedState.analytics) {
                appState.analytics = parsedState.analytics;
            }
            // 加载关卡相关的状态
            if (typeof parsedState.currentLevel !== 'undefined') {
                appState.currentLevel = parsedState.currentLevel;
            }
            if (parsedState.levelAttempts) {
                appState.levelAttempts = parsedState.levelAttempts;
            }
            if (parsedState.retryQuestions) {
                appState.retryQuestions = parsedState.retryQuestions;
            }
        }
    } catch (error) {
        console.error('加载游戏状态失败:', error);
    }
}

// 保存成就到本地存储
function saveAchievementToLocalStorage(achievementName) {
    try {
        let achievements = JSON.parse(localStorage.getItem('achievements') || '[]');
        if (!achievements.includes(achievementName)) {
            achievements.push(achievementName);
            localStorage.setItem('achievements', JSON.stringify(achievements));
        }
    } catch (error) {
        console.error('保存成就失败:', error);
    }
}

// 初始化应用
initApp();